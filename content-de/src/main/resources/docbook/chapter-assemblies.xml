<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="assemblies">
  <title>Maven Assemblies</title>

  <section id="assemblies-sect-intro">
    <title>Einführung</title>

    <para>Maven bietet Plugins welche eingesetzt werden können um die
    häufigsten Typen von Archiven zu erzeugen. Die meisten derer können
    wiederum von anderen Projekten als Abhängigkeit eingebunden werden. Einige
    Beispiele hierfür sind <acronym>JAR</acronym>, <acronym>WAR</acronym>,
    <acronym>EJB</acronym> und <acronym>EAR</acronym> Plugins. Wie bereits im
    Kapitel <xref linkend="lifecycle" /> angesprochen, entsprechen sich die
    verschiedenen Paketierungstypen dieser Plugins den meist geringfügig
    unteschiedlichen Build Prozessen. Während Maven mittels Plugins und
    angepassten Lebenszyklen die standard Paketierungstypen unterstützt, gibt
    es dennoch Situationen in welchen Sie ein angepasstes Archive oder
    Verzeichnis mit einenem spezifischen Layout erstellen müssen. Solche
    angepasste Layoutstrukturen nennt man Assemblies.</para>

    <para>Es gibt eine Reihe guter Gründe warum Sie ein zugeschnittenes Archiv
    für Ihr Projekt erstellen würden. Der wichtigste Grund ist die Verteilung.
    Das Wort "Verteilung" wird für unterschiedliche Personen (und Projekte)
    ganz unterschiedliche Bedeutungen haben, abhängig davon, wie ein Projekt
    zum Einsatz kommen soll. Im wesentlichen erlauben derartige Archive eine
    praktische Art die Projektergebnisse zu installieren oder anderweitig
    zugänglich zu machen. In manchen Fällen kann dies bedeuten eine
    Webanwendung mit einem Applikationsserver wie z.B. Jetty zu Bündeln. In
    andern mag es bedeuten die Dokumentation eines API zusammen mit den
    Quellen und den Binaries wie in eine <acronym>JAR</acronym> Datei
    zusammenzupacken. Assemblies sind gewöhnlich nützlich, wenn Sie die
    endgültige Version eines Produktes erstellen. Zum Beispiel sind Produkte
    wie Nexus, vorgestellt im Kapitel <xref linkend="repository-manager" />,
    das Produkt eines grossen multi-modularen Maven Projektes, und das Archiv,
    welches Sie letztendlich von Sonatype herunterladen wurde mittels eines
    Maven Assembly erstellt.</para>

    <para>In den meisten Fällen ist das Assembly Plugin am besten geeignet
    eines Projektes Verteilpaket zu erstellen. Jedoch müssen Assemblies nicht
    unbedingt veteilbare Archive darstellen; Assemblies sind gedacht, dem
    Maven Benutzer eine flexible Möglichkeit zu schaffen, massgeschneiderte
    Archive jeglicher Art zu erstellen. Im wesentlichen sind Assemblies dazu
    da, die Lücken zwischen den standard Archivformaten wie sie die
    Paketierungstypen bieten zu schliessen. Natürlich könnten Sie auch ein
    komplettes Maven Plugin schreiben um Ihr spezifisches Archivformat zu
    erstellen; zusammen mit der dazugehörenden Lebenszyklusabbildung und der
    Konfiguration der Artefaktverarbeitung um Maven zu beschreiben was zu tun
    ist. Assemblies machen diesen Aufwand in den meisten Fällen unnötig indem
    sie eine generalisierte Unterstützung der Erstellung Ihrer speziellen
    Archivtypen bieten ohne allzuviel Zeit darauf zu verwenden Maven Code zu
    erstellen.</para>
  </section>

  <section id="assemblies-sect-basics">
    <title>Assembly Grundlagen</title>

    <para>Vor wir uns nun in die Details stürtzen bietet es sich an, erst noch
    über die zwei Haupt Goals des Maven Assembly Plugin zu reden:
    <varname>assembly:assembly</varname> sowie <varname>single mojo</varname>.
    Ich führe diese zwei Goals in unterschiedlicher Art und Weise auf, da dies
    besser aufzeigt, dass diese zwei Goals ganz unterschiedlich eingesetzt
    werden. Das Goal <varname>assembly:assembly</varname> ist darauf ausgelegt
    von der Befehlszeile gestartet zu werden, und sollte niemals an eine
    Lebeszyklusphase gebunden werden. Das Goal <varname>single mojo</varname>
    hingegen ist darauf ausgelegt, Teil des tägliche Build Ablaufes
    darzustellen, es sollte wie die meisten Goals an eine Phase Ihres Projekt
    Build Lebenszyklus gebunden werden.</para>

    <para>Der Hauptgrund dieses Unterschieds ist, dass das Goal
    <varname>assembly:assembly</varname> ein sogenanntes aggregierendes Mojo
    darstellt. Ein Mojo welches darauf ausgelegt ist, innerhalb eines
    Buildlaufes nur einmal ausgeführt werden, unabhängig wieviele Projekte
    Teil des Buildlaufes sind. Ein aggregierendes Mojo bezieht seine
    Konfiguration vom Ursprungsprojekt, gewöhnlich dem hierarchisch höchsten
    <acronym>POM</acronym> oder direkt als Parameter von der Befehlszeile.
    Sollte ein solches Mojo an eine Lebenszyklusphase gebunden werden, so kann
    dies unerwartete Nebeneffekte haben. Es kann zum Beispiel dazu führen,
    dass das Goal eine andere Phase vorgängig zur Ausführung bringt was darin
    endet, dass die Paketierungsphase zweimal durchlaufen wird.</para>

    <para>Da das Goal <varname>assembly:assembly</varname> ein aggregierendes
    Mojo darstellt, bringt dies etliche Probleme mit sich. Es sollte daher nur
    als einzelstehendes Mojo von der Befehlszeile aufgerufen werden. Binden
    Sie das Goal <varname>assembly:assembly</varname> niemals an eine
    Lebenszyklusphase. Das Goal <varname>assembly:assembly</varname> war das
    ursprüngliche Goal des Maven Assembly Plugin, es war nie darauf ausgelegt
    Teil eines normalen Buildlaufes zu sein. Als es sich herausstellte, dass
    das Erstellen von Assembly Archiven eine reguläre Anforderung an einen
    Buildlauf ist, wurde das Goal <varname>single Mojo</varname> entwickelt.
    Das Mojo geht davon aus, dass es an den richtigen Ort innerhalb eines
    Buildlaufes gebunden wurde, so dass es zum entsprechenden Zugriff auf die
    entsprechenden Dateien und Artefakte hat welche es zur erfolgreichen
    Ausführung (als Teil des Lebenszyklusses) eines grossen multi-modularen
    Maven Projektes braucht. In einer multi-modularen Umgebung wird das Goal
    <varname>single Mojo</varname> so oft ausgeführt, wie dieses an
    unterschiedliche <acronym>POM</acronym> gebunden ist. Im Gegensatz zum
    Goal <varname>assembly:assembly</varname> wird <varname>single
    Mojo</varname> nicht die vorgängige Ausführung einer anderen
    Lebenszyklusphase erzwingen.</para>

    <para>Das Maven Assembly Plugin stellt über diese zwei Goals hinaus
    etliche weitere Goals zur Verfügung. Die Vorstellung dieser anderen Mojos
    geht jedoch weit über dieses Kapitel hinaus, da diese Goals exotische
    sowie inzwischen überholte Anwendungsfälle addressieren und darüber hinaus
    fast nie gebraucht werden. Soweit möglich sollten Sie in jedem Fall das
    Goal <varname>assembly:assembly</varname> benutzen um ein Assembly ab der
    Befehlszeile zu erstellen, sowie das Goal <varname>single Mojo</varname>
    um dies an eine Lebenszyklusphase gebunden zu tun.</para>

    <section id="assemblies-sect-predefined">
      <title>Vordefinierte Assembly Descriptoren
      (Archiv-Beschreibungen)</title>

      <para>Auch wenn sich aus Gewohnheit viele Benutzer dafür entscheiden,
      Ihre eigene Achiv-Beschreibungen zu erstellen, so ist dies in den
      meisten Fällen genau genommen nicht notwendig. Das Assembly Plugin
      bietet für mehrere verbreitete Archiv-Typen bereits eingebaute
      Beschreibungen welche Sie benutzen können ohne auch nur eine Zeile
      Konfiguration zu schreiben. Die folgenden Assembly Deskriptoren
      (Archiv-Beschreibungen) sind bereits im Maven Assembly Plugin
      vordefiniert:</para>

      <variablelist>
        <varlistentry>
          <term><varname>bin</varname></term>

          <listitem>
            <para>Der Deskriptor <varname>bin</varname> wird benutzt, um die
            zum Projekt gehörende <filename>LIZENZ</filename>, das
            <filename>README</filename>/<filename>LIESMICH</filename> sowie
            die <filename>HINWEIS</filename>-Datei mit den Projekt Artefakten
            zusammenzupacken, wobei davon ausgegangen wird, dass das Projekt
            ein <acronym>JAR</acronym> erstellt. Stellen Sie sich dies als die
            kleinstmögliche Binärkomposition für in sich abgeschlossene
            Projekte vor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>jar-with-dependencies</varname></term>

          <listitem>
            <para>Der Deskriptor <varname>jar-with-dependencies</varname>
            erstellt ein <acronym>JAR</acronym> welches neben den Inhalten des
            Hauptprojekts auch alle entpackten Inhalte der Archive der
            Laufzeitabhängigkeitenenthält. Zusammen mit einem entsprechenden
            Main-Class Eintrag im Manifest (wird unter "Plugin Konfiguration"
            weiter unten besprochen) kann ein solcher Deskriptor ein in sich
            abgeschlossenes ausführbares <acronym>JAR</acronym> Ihres
            Projektes erstellen, auch wenn dieses Abhängigkeiten zur Laufzeit
            hat.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>project</varname></term>

          <listitem>
            <para>Der Deskriptor <varname>project</varname> sichert die
            Struktur Ihres Projektes wie dieses auf Ihrem Dateisystem und
            ebenfalls wahrscheinlich, in Ihrem Quellcode Repository besteht.
            Natürlich ist das Zielverzeichnis hierbei ausgenommen, genau wie
            auch eventuelle Metadaten der Versions Kontroll Software (z.B. CVS
            und .svn Verzeichnisse, an welche wir uns alle gewöhnt haben). Der
            Sinn dieses Deskriptors ist lediglich ein Projekt Archiv zu
            erstellen, welches nach dem entpacken bereitsteht um Maven darauf
            auszuführen.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>src</varname></term>

          <listitem>
            <para>Der Deskriptor <varname>src</varname> erzeugt ein Archiv
            Ihrer Projekt Quellen sowie der <filename>pom.xml</filename>
            Dateien, zusammen mit allen notwendigen
            <filename>LIZENZ</filename>-,
            <filename>README</filename>-/<filename>LIESMICH</filename>- und
            <filename>HINWEIS</filename>-Dateien welche sich im
            Hauptverzeichnis befinden. Dieser Vorläufer des Deskriptors
            project erzeugt ein Archiv, welches in den meisten Fällen von
            Maven verarbeitet werden kann. Jedoch, aufgrund der Annahme das
            sich alle Quellen und anderweitige Resourcen im Standarverzeichnis
            <filename>/src</filename> befinden, besteht die Gefahr, dass alle
            nicht im Standard liegenden Verzeichnisse - und mit diesen Dateien
            welche für den Build entscheidend sein mögen - verlohren
            gehen.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="assemblies-sect-building">
      <title>Erstellen eines Assembly</title>

      <para>Das Assembly Plugin kann auf zweierlei Weise aufgerufen werden:
      Sie können es direkt von der Befehlszeile aufrufen, oder Sie können es
      als Teil Ihres Buildprozesses anstossen, indem Sie es an eine Phase des
      Build-Lebenszyklus binden. Der direkte Aufruf hat seine Berechtigung,
      insbesondere für Einzelzusammenstellungen welche nicht Teil Ihrer
      Hauptarbeit sind. In den meisten Fällen werden Sie Ihre
      Projektartefakten als Teil des normalen Buildprozesses paketieren. Diese
      Art des Vorgehens hat den Vorteil, dass Ihre angepassten Artefakte als
      Einheit in den Maven Repositorien abgelegt werden, unabhängig davon wo
      und wann das Projekt installiert oder verteilt werden soll. Es ist somit
      zu jeder Zeit für die Benuzter verfügbar.</para>

      <para>Als Beispiel einer Anwendung eines direkten Aufrufs des Assembly
      Plugins, stellen Sie sich vor Sie möchten jemandem eine Kopie Ihres
      Projektes senden, in einer Form, dass diese Person das Projekt von den
      Quellen erstellen kann. Anstatt nur das Produkt Ihrer Arbeit
      zusammenzupacken, wollen Sie auch die Quellen einschliessen. Eine
      solcherlei Zusammenstellung wird sicher die Ausnahme sein, weshalb es
      auch nicht sinnvoll ist dieses als Bestandteil des POM zu definieren.
      Statt dessen können Sie den folgenden Aufruf absetzen:</para>

      <screen>$ <command>mvn -DdescriptorId=project assembly:single</command> 
...
[INFO] [assembly:single] 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.tar.gz 
[INFO] Building tar : /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.tar.bz2
[INFO] Building zip: /Users/~/mvn-examples-1.0/assemblies/direct-invocation/\
                      target/direct-invocation-1.0-SNAPSHOT-project.zip
...</screen>

      <para>Stellen Sie sich vor, Sie wollen ein
      <emphasis>ausführbares</emphasis> <acronym>JAR</acronym> aus Ihrem
      Projekt erstellen. Sollte Ihr Projekt vollständig eigenständig sein,
      ohne weitere Abhängigkeiten, so kann dies erreicht werden, indem man auf
      dem Hauptprojektartefakten die Konfiguration <varname>archive</varname>
      des <acronym>JAR</acronym> Plugin aufruft. Es ist jedoch so, dass die
      meisten Projekte Abhängigkeiten haben, und diese Abhängigkeiten müssen
      schliesslich in ein ausführbares <acronym>JAR</acronym> eingeschlossen
      werden. In einem solchen Fall werden Sie sicherstellen wollen, dass bei
      jedem Erstellen des Hauptartefaktes - des Projekt <acronym>JAR</acronym>
      - auch dieses <emphasis>ausführbare</emphasis> <acronym>JAR</acronym>
      erstellt wird.</para>

      <para>Unter der Annahme, dass die Hauptklasse des Projektes
      <classname>org.sonatype.mavenbook.App</classname> ist, so wird die
      folgende Konfiguration des <acronym>POM</acronym> ein ausführbares
      <acronym>JAR</acronym> erstellen:</para>

      <example>
        <title>Assembly Descriptor eines ausführbaren JAR</title>

        <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
  &lt;artifactId&gt;executable-jar&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;name&gt;Assemblies Executable Jar Example&lt;/name&gt;
  &lt;url&gt;http://sonatype.com/book&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;commons-lang&lt;/groupId&gt;
      &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
 &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;create-executable-jar&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;
                  jar-with-dependencies
                &lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
              &lt;archive&gt;
                &lt;manifest&gt;
                  &lt;mainClass&gt;org.sonatype.mavenbook.App&lt;/mainClass&gt;
                &lt;/manifest&gt;
              &lt;/archive&gt;
           &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Ich möchte Ihre Aufmerksamkeit auf zwei Besonderheiten des oben
      wiedergegebenen <acronym>POM</acronym> lenken: Erstens, anstelle des
      zuvor benutzten Elements <varname>descriptorId</varname> setzen wir den
      Konfigurationsabschnitt des Elements <varname>descriptorRefs</varname>
      ein. Ein solches Vorgehen erlaubt es verschiedene Assemblies während
      eines einzigen Laufes des Assembly Plugin zu erstellen; und das mit
      geringstmöglichem Zusatzaufwand in der Konfiguration. Zweitens setzt das
      Element <varname>archive</varname> innerhalb des Elements
      <varname>configuration</varname> das Haupt-Klassen Attribut des
      Manifests des erstellten <acronym>JAR</acronym>. Dieser Abschnitt ist
      gewöhnlich verfügbar für Plugins welche ein <acronym>JAR</acronym>
      erstellen, so wie hier für das <acronym>JAR</acronym> Plugin welches zur
      Erstellung der standard Projekt Paketierungs Typen zum Einsatz
      kommt.</para>

      <para>Sie können jetzt das ausführbare <acronym>JAR</acronym> erstellen,
      indem Sie <command>mvn package</command> aufrufen. Anschliessend noch
      die Ausgabe des Verzeichnisses, welche aufzeigt, dass ein zusätztliches
      <acronym>JAR</acronym> erzeugt wurde. Schliesslich versuchen wir das
      <acronym>JAR</acronym> auszuführen, als Beweis, dass dies tatsächlich
      ein ausführbares <acronym>JAR</acronym> ist:</para>

      <screen>$ <command>mvn package</command>
... (output omitted) ...
[INFO] [jar:jar]
[INFO] Building jar: ~/mvn-examples-1.0/assemblies/executable-jar/target/\
                     executable-jar-1.0-SNAPSHOT.jar
[INFO] [assembly:single {execution: create-executable-jar}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: ~/mvn-examples-1.0/assemblies/executable-jar/target/\
                     executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
... (output omitted) ...
$ <command>ls -1 target</command>
... (output omitted) ...
executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar
executable-jar-1.0-SNAPSHOT.jar
... (output omitted) ...
$ <command>java -jar \
        target/executable-jar-1.0-SNAPSHOT-jar-with-dependencies.jar </command>
Hello, World!</screen>

      <para>Von der vorausgehenden Ausgabe können Sie ablesen, das der normale
      Buildlauf nun einen zusätzlichen Artefakten - das ausführbare
      <acronym>JAR</acronym> - zu den bestehenden Artefakten, erstellt. Der
      neue Artefakt trägt einen klassifizierenden Bezeichner
      <varname>jar-with-dependencies</varname>. Da das <acronym>JAR</acronym>
      ausführbar sein soll, haben wir dieses versucht, und die erwartete
      Ausgabe "Hello, World!" bekommen.</para>
    </section>

    <section id="assemblies-sect-as-depend">
      <title>Assemblies als Abhängigkeit</title>

      <para>Sollten Sie im Laufe des normalen Buildprozesses Assemblies
      generieren, werden diese Artefakte Ihren normalen Projekt Artefakten
      zugefügt. Das bedeutet, diese werden in gleicher Weise in das Repository
      installiert und freigegeben und sind fortan wie diese aufzulösen. Jedes
      Assembly bekommt die gleichen Basiskoordinaten
      (<varname>groupId</varname>, <varname>artifactId</varname>, und
      <varname>version</varname>) wie das Projekt. Diese Artefakte sind jedoch
      Anhänge zum Hauptartefakt, was im Universum von Maven bedeutet, dass
      diese auf den selben Artefakten aufbauen aber eine andere Prägung haben.
      Ein paar Beispiele: Quellcode Assemblies enthalten die rohen Daten
      welche ein Build benötigt, <varname>jar-with-dependencies</varname>
      enthalten das Ergebnis eines Buildlaufes inklusive aller notwendigen
      Abhängigkeiten. Anhänge zu Artefakten dürfen eine Haupeigenschaft von
      Maven Projekten aushebeln, dass es genau einen Artefakt zu einem Projekt
      gibt. Das ist genau aus dem Grund möglich, da sie Anhänge zu einem
      Projekt darstellen.</para>

      <para>Da Assemblies/Zusammenstellungen (normalerweise) Anhänge zu einem
      Projekt sind, muss jeder Artefakt zusätzlich zu den Koordinaten
      (Bezeichnern) eine Kennzeichnung tragen, um diese vom Haupartefakten zu
      unterscheiden. Standardmässig ist diese Kennzeichnung die selbe wie die
      des Bezeichners des Deskriptors. Beim Einsatz der eingebauten Assembly
      Deskriptoren, wie im Beispiel oben, wird die Kennzeichnung gewöhnlich
      mit dem Bezeichner welcher im Feld <varname>descriptorRef</varname>
      benutzt wurde, gleichgesetzt.</para>

      <para>Nachdem Sie also ein Asembly neben einem Artefakten verteilt
      haben, wie können Sie dieses nun als Abhängigkeit in ein anderes Projekt
      einbinden? Die Antwort ist einfach: Erinnern Sie sich an die Abschnitte
      <xref linkend="simple-project-sect-maven-coordinates" /> sowie <xref
      linkend="pom-relationships-sect-more-coordinates" /> bezüglich der
      Abhängigkeiten von Projekten in Maven; Projekte definieren
      Abhängigkeiten zu anderen Projekten durch eine Kombination von vier
      Koordinaten: <varname>groupId</varname>, <varname>artifactId</varname>,
      <varname>version</varname>, und <varname>packaging</varname>. Im
      Abschnitt <xref linkend="profiles-sect-platform-classifier" />, wird
      gezeigt wie mehrere Ausprägungen eines Artefakts bestehen können und wie
      man die zusätzliche Koordinate <varname>classifier</varname> benutzt, um
      um mittels einem Wert von entweder <varname>win</varname> oder
      <varname>linux</varname> die richtige plattformspezifische Form
      auswählt. Zusamenstellungen können also wie normale Abhängigkeiten
      benutzt werden, wobei die normalen Koordinaten zum Einsatz kommen,
      zuzüglich dem notwendingen Element <varname>classifier</varname>, unter
      welchem der Artefakt installiert oder verteilt wurde. Sollte die
      Zusammenstellung nicht als <acronym>JAR</acronym> vorliegen, so muss
      zusätzlich der Typ angegeben werden.</para>
    </section>

    <section id="assemblies-sect-assembling-via-depend">
      <title>Zusammenstellen von Assemblies mittels Assembly
      Abhängigkeiten</title>

      <para>Ist das nicht ein verwirrender Titel? Lassen Sie uns ein Szenario
      entwerfen welches den Gedanken von zusammengestellten Assemblies
      verdeutlicht. Vielleicht möchten Sie ein Archiv erstellen, welches eine
      Anzahl Assemblies enthält. Gehen Sie einmal davon aus, dass Sie über ein
      multi-modulares Projekt verfügen, und nun ein Assembly verteilen
      möchten, welche aus einer Anzahl voneinander in Beziehung stehender
      Projekt Assemblies besteht. In diesem Abschnitt erstellen wir eine
      Bündelung von "build-baren" Projekt Verzeichnissen für eine Anzahl
      Projekte welche gewöhnlicherweise zusammen benutzt werden. Der
      Einfachheit halber werden wir die zwei oben ausgeführten - eingebaut
      vorhandenen - Deskriptoren <varname>project</varname> und
      <varname>jar-with-dependecies</varname> zum Einsatz bringen. In diesem
      speziellen Beispiel gehen wir davon aus, dass jedes Projekt zum normalen
      <acronym>JAR</acronym> Artefakt ebenfalls einen Artefakt eines Assembly
      <varname>project</varname> erstellt. Nehmen Sie darüber hinaus an, dass
      jedes Projekt des multi-modularen Buildlaufes das Goal
      <varname>single</varname> an die Phase <varname>packaging</varname>
      bindet und die <varname>descriptorRef</varname>
      <varname>project</varname> benutzt. Jedes Projekt eines multi-modularen
      Builds erbt diese Konfiguration von einem übergeordneten
      <acronym>POM</acronym> dessen Element
      <varname>pluginManagement</varname> in <xref
      linkend="ex-top-pom-assembly" /> ausgeführt ist.</para>

      <example id="ex-top-pom-assembly">
        <title>Konfiguration des Projekt Asseembly im top-level POM</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;pluginManagement&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.2-beta-2&lt;/version&gt;
          &lt;executions&gt;
            &lt;execution&gt;
              &lt;id&gt;create-project-bundle&lt;/id&gt;
              &lt;phase&gt;package&lt;/phase&gt;
              &lt;goals&gt;
                &lt;goal&gt;single&lt;/goal&gt;
              &lt;/goals&gt;
              &lt;configuration&gt;
                &lt;descriptorRefs&gt;
                  &lt;descriptorRef&gt;project&lt;/descriptorRef&gt;
                &lt;/descriptorRefs&gt;
              &lt;/configuration&gt;
            &lt;/execution&gt;
          &lt;/executions&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>Jedes untergeordnete Projekt <acronym>POM</acronym> referenziert
      die Plugin Konfiguration aus <xref linkend="ex-top-pom-assembly" /> in
      dem es eine minimale Plugin Deklaration im Build-Abschnitt des
      <acronym>POM</acronym> aufnimmt. Dies ist in <xref
      linkend="ex-activating-assembly" /> ausgeführt.</para>

      <example id="ex-activating-assembly">
        <title>Aktivierung der Assembly Plugin Konfiguration im
        Untermodul</title>

        <programlisting language="xml">&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</programlisting>
      </example>

      <para>Um die entsprechenden Projekt Assemblies zu erstellen, rufen Sie
      <command>mvn install</command> aus dem übergeordneten Verzeichnis auf.
      Sie sollten beobachten können, wie Maven die entsprechenden Artefakte
      mit entsprechenden Bezeichnern in Ihr lokales Repository
      installiert.</para>

      <screen>$ <command>mvn install</command>
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
           second-project/target/second-project-1.0-SNAPSHOT-project.tar.gz to 
  ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
           second-project-1.0-SNAPSHOT-project.tar.gz
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
           second-project/target/second-project-1.0-SNAPSHOT-project.tar.bz2 to 
  ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\
           second-project-1.0-SNAPSHOT-project.tar.bz2
...
Installing ~/mvn-examples-1.0/assemblies/as-dependencies/project-parent/\
           second-project/target/second-project-1.0-SNAPSHOT-project.zip to 
  ~/.m2/repository/org/sonatype/mavenbook/assemblies/second-project/1.0-SNAPSHOT/\\
           second-project-1.0-SNAPSHOT-project.zip
...</screen>

      <para>Beim Aufruf von <command>mvn install</command> wird Maven jeweils
      den Projektartefakten sowie das entsprechende Assembly in Ihr lokales
      Repository installieren. Alle diese Artefakte sind fortan für weitere
      Projekte mittels normaler Koordinaten referenzierbar. Sollte Ihr Ziel
      nun sein, ein Assembly bestehend aus den Assemblies mehrerer Projekte zu
      erstellen, so erreichen Sie dies, indem Sie ein weiteres Projekt
      erstellen, welches die entsprechenden Projekt Assemblies als
      Abhängigkeiten definiert. Dieses Bündel von Projekten (mit dem
      treffenden Namen bundle-project; engl. Bündelprojekt) trägt
      Verantwortung für die Erstellung der Zusammenstellung. Das entsprechende
      <acronym>POM</acronym> des Projektes ist im
      <acronym>XML</acronym>-Dokument von <xref linkend="ex-bundling-pom" />
      wiedergegeben.</para>

      <example id="ex-bundling-pom">
        <title>POM eines Assembly Bündel-Projektes</title>

        <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
  &lt;artifactId&gt;project-bundle&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;name&gt;Assemblies-as-Dependencies Example Project Bundle&lt;/name&gt;
  &lt;url&gt;http://sonatype.com/book&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;artifactId&gt;first-project&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;classifier&gt;project&lt;/classifier&gt;
      &lt;type&gt;zip&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;artifactId&gt;second-project&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;classifier&gt;project&lt;/classifier&gt;
      &lt;type&gt;zip&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;bundle-project-sources&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;
                  jar-with-dependencies
                &lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
      </example>

      <para>Dieses "Bündel"-Projekt <acronym>POM</acronym> referenziert die
      zwei Assemblies von den Projekten <varname>first-project</varname> und
      <varname>second-project</varname>. Statt der Hauptartefakte jedes
      Projektes referenziert das <acronym>POM</acronym> die Koordinaten mit
      Bezeichner und einem Typ <varname>zip</varname>. Dies fordert Maven dazu
      auf, das <acronym>ZIP</acronym> Archiv aufzulösen, welches von der
      entsprechenden Zusammenstellung erstellt wurde. Beachten Sie, dass das
      Bündelprojekt eine Zusammenstellung der Art
      <varname>jar-with-dependencies</varname> erstellt.</para>

      <para><varname>jar-with-dependencies</varname> erzeugt kein besonders
      elegantes Archiv, es erzeugt lediglich ein einziges
      <acronym>JAR</acronym> mit dem entpackten Inhalt aller Abhängigkeiten.
      Dieser Typ weist Maven also an, alle Abhängigkeiten zusammenzutragen,
      alle <acronym>JAR</acronym>s zu entpacken um diese anschliessend alle in
      ein einziges <acronym>JAR</acronym>, zusammen mit den Projektartefakten
      zusammenzupacken. In diesem Beispiel erzeugt dies ein einziges
      <acronym>JAR</acronym> mit den Inhalten von den Projekten
      <varname>first-project</varname> und <varname>second-project</varname>
      Seite an Seite.</para>

      <para>Diese Beispiel zeigt auf, wie man die grundlegenden Möglichkeiten
      des Maven Assembly Plugin verbinden kann, um Artefakte zu erzeugen ohne
      einen speziell angepassten Assembly Deskriptor zu benötigen. Wir
      erreichen unser Ziel durch die Erstellung eines einzigen Archives
      welches die verschiedenen Projektverzeichnisse Seite an Seite enthält.
      In diesem Fall wird <varname>jar-with-dependencies</varname> nur als
      Speicherformat benutzt, weshalb wir auch kein Attribut Main-Class
      bestimmen. Um das Bündel zu erstellen starten wir eine gewöhnlichen
      Build Lauf des Projektes:</para>

      <screen>$ <command>mvn package</command>
...
[INFO] [assembly:single {execution: bundle-project-sources}]
[INFO] Processing DependencySet (output=)
[INFO] Building jar: ~/downloads/mvn-examples-1.0/assemblies/as-dependencies/\
  project-bundle/target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar
</screen>

      <para>Um zu überprüfen, dass die Bündelprojekt-Assembly tatsächlich die
      entpackten Inhalte der abhängigen Zusammenstellungen enthält können Sie
      <command>jar tf</command> aufrufen:</para>

      <screen>$ <command>jar tf \
  target/project-bundle-1.0-SNAPSHOT-jar-with-dependencies.jar</command>
...
first-project-1.0-SNAPSHOT/pom.xml
first-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
first-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java
...
second-project-1.0-SNAPSHOT/pom.xml
second-project-1.0-SNAPSHOT/src/main/java/org/sonatype/mavenbook/App.java
second-project-1.0-SNAPSHOT/src/test/java/org/sonatype/mavenbook/AppTest.java</screen>

      <para>Jetzt da Sie diesen Abschnitt gelesen haben, sollte sich auch der
      Sinn des Titels besser erschliessen. Sie haben ein Assembly zweier
      projektspezifischer Zusammenstellung erstellt, indem Sie ein Projekt
      eingefügt haben welches beide Artefakte als Abhängigkeit
      definiert.</para>
    </section>
  </section>

  <section id="assemblies-sect-overview-descriptor">
    <title>Übersicht eines Assembly Descriptors</title>

    <para>Sobald die standard Assembly Deskriptoren wie diese in<xref
    linkend="assemblies-sect-basics" /> eingeführt wurden nicht ausreichen,
    werden Sie Ihren eingenen Deskriptor erstellen. Ein Assembly Deskriptor
    ist ein <acronym>XML</acronym> Dokument, welches die Struktur und den
    Inhalt einer Zusammenstellung festlegt.</para>

    <figure>
      <title>Schematische Abbildung eines Assembly Descriptor</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="figs/web/assemblies_descriptor.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Die Konfiguration eines Assembly Deskriptors ist in fünf Abschnitten
    gegliedert, mit zwei Optionalen: eines um standard Assembly-Fragmente zu
    definieren, sogenannte Komponenten Deskriptoren sowie einem weiteren
    Abschnitt um spezifische Dateiverarbeitungsklassen zu benennen, welche
    benötigt werden um eine Zusammenstellung zu erstellen. Im folgenden eine
    Beschreibung der fünf Hauptabschnitte:</para>

    <variablelist>
      <varlistentry>
        <term>Base Configuration / Basiskonfiguration</term>

        <listitem>
          <para>Dieser Abschnitt enthält Informationen welche von allen
          Assemblies benötigt werden, sowie einige zusätzliche
          Konfigurationselemente welche optional gebraucht werden können und
          sich auf das Format des Gesamtarchivs beziehen. Um einen
          vollständigen Assembly Deskriptor zu erstellen ist es notwendig
          zumindest die Assembly ID, eine Formatangabe sowie einen der
          nachfolgenden Abschitte anzugeben.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>File Information / Datei Informationen</term>

        <listitem>
          <para>Die Konfigurationen in diesem Abschnitt beziehen sich auf
          spezifische Dateien des Dateisystems welche in den
          Projektverzeichnissen liegen. Dieser Abschnitt hat zwei wichtige
          Unterabschnitte <varname>files</varname> (Dateien) und
          <varname>fileSets</varname> (Dateigruppierungen). Sie benutzen diese
          beiden Abschnitte um Datein und Gruppierungen von Dateien
          Zugriffsberechtigungen zuzuweisen und um diese in einem Assembly
          ein- oder auszuschliessen.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Dependency Information / Informationen zu den
        Abhängigkeiten</term>

        <listitem>
          <para>Beinahe alle Projekte jeglicher Grösse sind von anderen
          Projekten abhängig. Bei der Erstellung von Archieven für die
          Verteilung werden gewöhnlich alle Abhängigkeiten in die
          Zusammenstellung eingeschlossen. Dieser Abschnitt definiert, in
          welcher Weise Abhängigkeiten in einem resultierenden Archiv
          eingeschlossen werden. Dieser Abschnitt erlaubt es zu definieren, ob
          Abhängigkeiten entpackt werden, diese direkt in das lib-Verzeichnis
          eingeschlossen werden oder gar auf einen anderen Namen abgebildet
          werden sollen. Darüberhinaus erlaubt Ihnen dieser Abschnitt die
          Zugriffsrechte auf die Abhängigkeiten zu setzen, sowie festzlegen,
          welche Abhängigkeiten überhaupt eingeschlossen werden.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Repository Information / Repository Informationen</term>

        <listitem>
          <para>Manchmal ist es nützlich, kann man die Gesamtheit aller
          nowendigen Artefakte eingrenzen, welche benötigt werden ein Projekt
          zu erstellen. Solche Artefakte können Abhängigkeiten,
          <acronym>POM</acronym>-Dateien von abhängigen Artefakten, oder auch
          übergeordnete <acronym>POM</acronym>-Dateien sein. In diesem
          Abschnitt ist es möglich ein oder mehr Repository Systeme in Ihre
          Zusammenstellung aufzunehmen, inklusive mehrer möglichen
          Konfigurationen. Zu diesem Zeitpunkt ist es nicht möglich,
          Plugin-Artefakte in diesen Repositorien aufzunehmen.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Module Information / Informationen zu den Modulen</term>

        <listitem>
          <para>Dieser Abschnitt erlaubt Ihnen vererbliche Strukturen bei der
          Definition von Assemblies auszunutzen, um entsprechende
          Quell-Dateien, Artefakte und Abhängigkeiten des übergeordneten
          Moduls einzuschliessen. Dieser Abschnitt ist der komplexeste des
          gesamten Assembly Deskriptors, denn dieser Abschnitt ermöglicht
          Ihnenn auf zweierlei Weise mit Modulen und Untermodulen zu arbeiten:
          zum einen als Anzahl von fileSets (mittels den Abschnitten bezüglich
          Quellen) oder in Bezug auf dependencySets (mittels den Abschnitten
          bezüglich der Binaries).</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section id="assemblies-sect-descriptor">
    <title>Der Assembly Descriptor</title>

    <para>Dieser Abschnitt ist eine kurze Übersicht über den Assembly
    Deskriptor, wir werden versuchen Ihnen ein paar Tips und Leitgaben zur
    Erstellung von benutzerdefinierten Assembly Deskriptoren zu geben. Das
    Assembly Plugin ist das grösste Plugin der Maven Familie und auch eines
    der flexibelsten.</para>

    <section id="assemblies-sect-prop-refs">
      <title>Property Referenzen in Assembly Descriptoren</title>

      <para>Jedes im Kapitel <xref
      linkend="resource-filtering-sect-properties" /> vorgestellte Property
      kann innerhalb eines Assembly Deskriptors referenziert werden. Vor der
      Verarbeitung jeglicher Assembly Deskriptoren von Maven, wird dieser mit
      den Informationen des <acronym>POM</acronym> und der aktuellen
      Build-Umgebung abgeglichen. Alle innerhalb von
      <acronym>POM</acronym>-Dateien zulässigen Properties sind auch in
      Assembly Deskriptoren gültig, einschliesslich <acronym>POM</acronym>
      Properties, Werte von <acronym>POM</acronym> Elementen, System
      Properties, benutzerdefinierte Properties wie auch
      Betriebssystemvariablen.</para>

      <para>Es gibt eine einzige Ausnahme bezüglich diesem Auswertungsschritt:
      die Elemente der verschiedenen Unterabschnitte unterhalb von
      <varname>outputDirector</varname>,
      <varname>outputDirectoryMapping</varname> und
      <varname>outputFileNameMapping</varname>. Diese Elemente werden von der
      Verarbeitung ausgeschlossen, um zu ermöglichen, dass Artefakt- oder
      Modul-spezifische Änderungen bei der Auflösung der Elemente eingebracht
      werden können.</para>
    </section>

    <section id="assemblies-sect-required">
      <title>Notwendige Basisinformationen für Assemblies</title>

      <para>Es gibt zwei grundlegende Einträge, welche für jegliches Assemby
      benötigt werden: die Kennung (ID) und eine Liste der Archivformate
      welche erstellt werden sollen. Tatsächlich braucht es mindestens noch
      einen weiteren Eintrag im Deskriptor - die meisten Archiv-Prozessoren
      benötigen die Angabe mindestens einer Datei - aber ohne Kennung (ID) und
      Formatangabe gibt es in keinem Fall ein zu erzeugendes Archiv. Die
      Kennung findet nicht nur im Namen des Archivs Verwendung, sondern auch
      als Teil des Artefakt Bezeichners innerhalb des Maven Repositories. Der
      Format-Eintrag bestimmt die Instanz des archivierenden Prozessors welche
      das schliessendliche Archiv der Zusammenstellung erzeugt. Alle Assembly
      Deskriptoren müssen daher mindestens eine Kennung (ID) sowie einen
      Formateintrag enthalten:</para>

      <example id="ex-required-assembly">
        <title>Notwendige Elemente eines Assembly Descriptors</title>

        <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;bundle&lt;/id&gt; 
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
  &lt;/formats&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>Der Eintrag der Kennung (id) kann eine beliebige Zeichenkette
      sein, diese darf allerdings keine Leerschläge enthalten. Normalerweise
      werden als Worttrennzeichen Bindestriche eingesetzt. Sollten Sie zum
      Beispiel eine Zusammenstellung einer besonderen, einmaligen
      Paketstruktur erstellen, so könnten Sie auf eine Kennung
      '<varname>besondere-einmalige-Paketstruktur</varname>' zurückgreifen.
      Verschiedene Archivformate einer Zusammenstellung werden gleichzeitig in
      einem einzigen Assembly Deskriptor unterstützt, dies erlaubt es Ihnen
      die bekannten Formate .zip, .tar.gz sowie .tar.bz2 der Archive zur
      Verteilung einfach zu ertellen. Sollten Sie das von ihnen erwünschte
      Archivformat nicht finden, so können Sie ein eigenes Format definieren.
      Benutzerdefinierte Formate werden weitergehend im Abschnitt <xref
      linkend="assemblies-sect-componentDescriptors" /> behandelt. Das
      Assembly Plugin bietet direkte Untertützung für die folgenden
      Formate:</para>

      <itemizedlist>
        <listitem>
          <para><varname>jar</varname></para>
        </listitem>

        <listitem>
          <para><varname>zip</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar</varname></para>
        </listitem>

        <listitem>
          <para><varname>bzip2</varname></para>
        </listitem>

        <listitem>
          <para><varname>gzip</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar.gz</varname></para>
        </listitem>

        <listitem>
          <para><varname>tar.bz2</varname></para>
        </listitem>

        <listitem>
          <para><varname>rar</varname></para>
        </listitem>

        <listitem>
          <para><varname>war</varname></para>
        </listitem>

        <listitem>
          <para><varname>ear</varname></para>
        </listitem>

        <listitem>
          <para><varname>sar</varname></para>
        </listitem>

        <listitem>
          <para><varname>dir</varname></para>
        </listitem>
      </itemizedlist>

      <para>Die Elemente <varname>id</varname> und <varname>format</varname>
      sind auch deshalb so wichtig, da diese einen Bestandteil der Koordinaten
      der Zusammenstellung abgeben. So ergibt sich aus dem Beispiel <xref
      linkend="ex-required-assembly" /> eine Zusammenstellung vom Typ
      <varname>zip</varname> mit der Artefakt Bezeichnung
      <varname>bundle</varname>.</para>
    </section>
  </section>

  <section id="assemblies-sect-controlling-contents">
    <title>Bestimmen des Inhaltes eines Assemblies</title>

    <para>Theoretisch reichen die Elemente <varname>id</varname> und
    <varname>format</varname> für einen zulässigen Assembly Deskriptor; es ist
    jedoch so, dass viele Archiv Prozessoren scheitern, ist nicht mindesten
    eine Datei vorhanden welche dem resultierenden Archiv zugefügt wird. Die
    Aufgabe zu definieren welche Dateien tatsächlich einem Archiv zugefügt
    werden sollen, fällt den fünf Hauptabschnitten des Assembly Deskriptors
    zu: <varname>files</varname>, <varname>fileSets</varname>,
    <varname>dependencySets</varname>, <varname>repositories</varname> und
    <varname>moduleSets</varname>.</para>

    <para>Um diese Abschnitte rasch einzuführen, fangen wir mit dem
    elementarsten Element an: <varname>files</varname>. Fortfahren werden wir
    mit den zwei am häufigsten benutzten Abschnitten:
    <varname>fileSets</varname> und <varname>dependencySets</varname>. Danach
    ist es ein Leichtes auch noch <varname>repositories</varname> und
    <varname>moduleSets</varname> einzuführen.</para>

    <section id="assemblies-sect-files">
      <title><sgmltag>Element files</sgmltag></title>

      <para>Das Element <varname>files</varname> ist das einfachste Element
      eines Assembly Deskriptors, es ist daarauf ausgelegt Dateien zu
      bezeichnen, welche eine relativ zum Projektverzeichnis bestimmte Lage
      besitzen. Der Einsatz dieses Elements gibt Ihnen die volle Kontrolle
      über genau die Dateien welche Sie in Ihre Zusammenstellung einbinden
      möchten, es lässt Sie genau bestimmen wie diese benannt werden sollen
      und wo im Archiv diese abgelegt werden.</para>

      <example id="ex-assembly-files">
        <title>Einschlissen einer <acronym>JAR</acronym> Datei in ein Assembly
        mittels dem Element <sgmltag>files</sgmltag></title>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;files&gt;
    &lt;file&gt;
      &lt;source&gt;target/my-app-1.0.jar&lt;/source&gt;
      &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt;
      &lt;destName&gt;my-app.jar&lt;/destName&gt;
      &lt;fileMode&gt;0644&lt;/fileMode&gt;
    &lt;/file&gt;
  &lt;/files&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>Unter der Annahme, dass Sie ein Projekt namens
      <filename>my-app</filename> in Version <filename>1.0</filename>
      erstellen, so würde in <xref linkend="ex-assembly-files" /> Ihr Projekt
      <acronym>JAR</acronym> im Verzeichnis <filename>lib</filename> abgelegt,
      die Version aus dem Dateinamen herausgterennt, so dass die resultierende
      Datei nur noch <filename>my-app.jar</filename> heisst. Das
      <acronym>JAR</acronym> würde global lesbar, aber nur für Eigner
      schreibberechtigt werden (das ist die Bedeutung des Elements
      <varname>fileMode</varname> 0644 auf Dateien angewandt; in Unix
      vierstelliger Benutzerrechtsnotation). Weitere Informationen bezüglich
      des Formats der Werte des Elements <varname>fileMode</varname> finden
      Sie im Wikipedia-Eintrag bezüglich der vierstelligen
      Benutzerrechtsnotation (<ulink
      url="http://en.wikipedia.org/wiki/File_system_permissions#Octal_notation_and_additional_permissions">four-digit
      Octal notation</ulink>).</para>

      <para>Sie können, unter der Voraussetzung dass Ihnen die genauen Dateien
      bekannt sind, eine sehr komplexe Zusammenstellung mittels Elementen
      <varname>file</varname> vornehmen. Sie könnten diese sogar soweit
      ausbauen, dass Sie mit einem benutzerdefinierten Plugin die Liste der
      Dateien erstellen, woraus Sie dann den Assembly Deskriptor generieren
      indem Sie Elemente, wie oben ausgeführt, einfügen. Obwohl die einzelne
      Auflistung jeder Datei, deren Namen, Lokation und Berechtigungen
      innerhalb einer Zusammenstellung Ihnen genaueste Kontrolle gibt, so ist
      dies ein sehr mühsames Vorgehen. Im Allgemeinen werden Sie auf
      Gruppierungen von Dateien und Abhängigkeiten arbeiten, Sie tun dies
      durch die Verwendung von Elementen <varname>fileSets</varname>. Die
      weiteren vier Abschnitte zur Auswahl von Dateien sind darauf ausgelegt
      ganze Dateigruppen welche bestimmten Kriterien entsprechen, zu
      bearbeiten.</para>
    </section>

    <section id="assemblies-sect-filesets">
      <title><sgmltag>Element fileSets</sgmltag></title>

      <para>Ähnlich des Abschnitts über die Datei Auswahl (Element
      <varname>files</varname>) befasst sich auch das Element
      <varname>fileSet</varname> mit Dateien die einen bestimmten relativen
      Ort zum Projektverzeichnis besitzen. Jedoch, im Gegensatz zu Element
      <varname>files</varname> beschreibt das Element
      <varname>fileSets</varname> Gruppierungen von Dateien, definiert durch
      Datei-und Pfadmuster welchen diese entsprechen (oder eben nicht
      entsprechen!) und der allgemeinen Verzeichnisstruktur in welcher diese
      sich befinden. Das einfachste <varname>fileSet</varname> definiert
      lediglich das Verzeichnis in welchem sich die Dateien befinden.</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/java&lt;/directory&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  ...
&lt;/assembly&gt;</programlisting>

      <para>Das oben abgebildete Element <varname>fileSet</varname> schliesst
      lediglich den Inhalt des Verzeichnisses
      <filename><filename>src/main/java</filename></filename> unseres
      Projektes ein. Es nutzt hierbei viele der bestehenden
      Standardeinstellungen, welche wir im folgenden genauer ansehen
      wollen.</para>

      <para>Zuallererst fällt auf, dass wir im Element
      <varname>fileSet</varname> gar nicht angeben, wo innerhalb der
      Zusammenstellung die entsprechenden Dateien abgelegt werden sollen.
      Standardmässig ist das Zielverzeichnis (angegeben im Element
      <varname>outputDirectory</varname>) dasselbe wie das Quellverzeichnis
      (in unserem Fall das Verzeichnis <filename>src/main/java</filename>).
      Zusätzlich haben wir keinerlei Ein- oder Ausschlusskriterien in Form von
      Dateimustern definiert. Werden diese nicht angegeben, so wird davon
      ausgegangen, dass Sie alle Dateien des Quellverzeichnisses
      einschliessen, mit einigen wenigen, wichtigen Ausnahmen. Diese Ausnahmen
      betreffen zumeist Meta-Daten von Source Control Systemen und deren
      Verzeichnisse, diese werden durch die Einstellung
      <varname>useDefaultExcludes</varname> gesetzt, welche standarmässig auf
      <emphasis>true</emphasis> gesetzt ist. Solange dies aktiviert ist wird
      die Einstellung <varname>useDefaultExclude</varname> Verzeichnisse wie
      <filename>.svn</filename> und <filename>CVS</filename> aus einer
      Zielzusammenstellung heraushalten. Der Abschnitt <xref
      linkend="assemblies-sect-default-excludes" /> gibt eine detailierte
      Liste der standard Auschlussmuster.</para>

      <para>Sollten wie innerhalb eines Elements <varname>fileSet</varname>
      mehr Kontrolle ausüben wollen, so können wir dies. <xref
      linkend="ex-explicit-fileSet" /> gibt ein Element
      <varname>fileSet</varname> wieder, bei welchem alle Standardelemente
      gesetzt sind:</para>

      <example id="ex-explicit-fileSet">
        <title>Einschliessen von Dateien mittles dem Element
        <sgmltag>fileSet</sgmltag></title>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/java&lt;/directory&gt;
      &lt;outputDirectory&gt;src/main/java&lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;**&lt;/include&gt;
      &lt;/includes&gt;
      &lt;useDefaultExcludes&gt;true&lt;/useDefaultExcludes&gt;
      &lt;fileMode&gt;0644&lt;/fileMode&gt;
      &lt;directoryMode&gt;0755&lt;/directoryMode&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
      </example>

      <para>Das Unterelement <varname>includes</varname> besteht aus einer
      Liste von Elementen <varname>include</varname> welche Pfadmuster
      definieren. Diese Muster können auch Jokerzeichen im "ant"-Stil
      beinhalten, wobei '**' bedeutet: passt zu einem oder mehr
      Verzeichnissen, '*' passt auf Teil eines Dateinamens und '?' welches ein
      einziges Zeichen ersetzt.<xref linkend="ex-explicit-fileSet" /> benutzt
      hierbei ein Element <varname>fileMode</varname> welches definiert, dass
      die resultierenden Einträge von allen gelesen werden können, aber nur
      Eigner Schreibrechte besitzen. Da das Element <varname>fileSet</varname>
      auch Verzeichnisse einschliesst, besteht wiederum die Möglichkeit das
      Element <varname>directoryMode</varname> zu setzen, welches dem Element
      <varname>fileMode</varname> sehr ähnliche Funtionalitäten aufweist. Da
      die Berechtigung ein Verzeichnis "auszuführen" auf das Auflisten des
      Inhaltes abgebildet wird, stellen wir sicher, dass Verzeichnisse nebst
      "lesbar" auch "ausführbar" (also aufzulisten) sind. Wie auch schon bei
      Dateien werden nur Eigentümer Schreibrechte besitzen.</para>

      <para>Das Element <varname>fileSet</varname> bietet aber auch noch
      weitere Möglichkeiten. Zunächst einmal erlaubt es den Einschluss eines
      Elements <varname>excludes</varname> in gleicher Weise wie bereits das
      Element <varname>includes</varname> definiert wurde. Diese
      Auschlusskriterien erlauben es Ihnen bestimmte Dateien aus dem
      resultierenden <varname>fileSet</varname> auszuschliessen.
      Einschlusskriterien übersteuern hierei Auschlusskriterien. Zusätzlich
      können Sie die Einstellung <varname>filtering</varname> auf
      <emphasis>true</emphasis> setzen, sollten Sie bestimmte Ausdrücke bei
      den eingeschlossenen Dateien durch Property-Werte ersetzen wollen.
      Ausdrücke können entweder durch <varname>\${</varname> und
      <varname>}</varname> (normale Maven Ausdrücke wie z.B.
      <varname>\${project.groupId}</varname>) oder durch
      <varname>@</varname>variable<varname>@</varname> (normale Ant Ausdrücke
      wie z.B. <varname>@project.groupId@</varname>) eingeleitet werden. Sie
      können das Zeilenabschlusszeichen Ihrer Dateien durch das Element
      <varname>lineEnding</varname> bestimmen. Erlaubte
      Zeilenabschlusselemente sind:</para>

      <variablelist>
        <varlistentry>
          <term>keep</term>

          <listitem>
            <para>Erhalten des Zeilenumbruch-Zeichen der Quelldatei (dies ist
            der Standardwert)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>unix</term>

          <listitem>
            <para>Unix-artiger Zeilenumbruch</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>lf</term>

          <listitem>
            <para>Ausschliesslich Zeilenvorschub</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>dos</term>

          <listitem>
            <para>MS-DOS-artiger Zeilenumbruch</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>crlf</term>

          <listitem>
            <para>Zeilenumbruch gefolgt von einem Zeilenvorschub</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Schliesslich, sollten Sie wirklich alle Dateiauswahlkriterien
      einsetzen wollen, so können Sie auch noch das Element
      <varname>useStrictFiltering</varname> auf einen Wert von
      <emphasis>true</emphasis> setzen (Standard ist
      <emphasis>false</emphasis>). Dies ist immer dann nützlich, wenn
      unbenutzte Muster andeuten, dass in Zwischenablage-Verzeichnissen
      gewisse Dateien fehlen. Sollte das Element
      <varname>useStrictFiltering</varname> auf <emphasis>true</emphasis>
      gesetzt sein, so bricht das Assembly Plugin ab, sollte eines der Muster
      nicht erfüllt werden, d.h. keine passende Datei gefunden werden. In
      anderen Worten, sollten Sie ein Einschlusskriterium gesetzt haben und
      die entsprechende Datei aus einem Build Lauf ist nicht vorhanden, so
      wird Maven einen Fehler annehmen und abbrechen.</para>
    </section>

    <section id="assemblies-sect-default-excludes">
      <title>Standard Auschlussmuster in <sgmltag>fileSets</sgmltag></title>

      <para>Beim Einsatz der Standard-Ausschlussmuster, wird das Maven
      Assembly Plugin mehr als nur die <acronym>SVN-</acronym> und
      <acronym>CVS-</acronym> Datein und Verzeichnisse ignorieren.
      Standardmässig sind die Auschlussmuster durch die Klasse <ulink
      url="http://svn.codehaus.org/plexus/plexus-utils/trunk/src/main/java/org/codehaus/plexus/util/DirectoryScanner.java">DirectoryScanner</ulink>
      des Projektes <ulink
      url="http://plexus.codehaus.org/plexus-utils/">plexus-utils</ulink>
      welches von Codehaus gehostet wird festgelegt. Die Menge der
      Auschlussmuster ist als <code>static final StringArray</code> mit dem
      Namen <varname>DEFAULTEXCLUDES</varname> in
      <classname>DirectoryScanner</classname> definiert. Der Inhalt des Array
      wird in <xref linkend="ex-default-excludes" /> wiedergegeben:</para>

      <example id="ex-default-excludes">
        <title>Definition von Standard Ausschlussmustern von Plexus
        Utils</title>

        <programlisting language="java">   public static final String[] DEFAULTEXCLUDES = {
        // Miscellaneous typical temporary files
        "**/*~",
        "**/#*#",
        "**/.#*",
        "**/%*%",
        "**/._*",

        // CVS
        "**/CVS",
        "**/CVS/**",
        "**/.cvsignore",

        // SCCS
        "**/SCCS",
        "**/SCCS/**",

        // Visual SourceSafe
        "**/vssver.scc",

        // Subversion
        "**/.svn",
        "**/.svn/**",

        // Arch
        "**/.arch-ids",
        "**/.arch-ids/**",

        //Bazaar
        "**/.bzr",
        "**/.bzr/**",

        //SurroundSCM
        "**/.MySCMServerInfo",

        // Mac
        "**/.DS_Store"
    };</programlisting>
      </example>

      <para>Die Standardmenge der Ausschlussmuster schliesst Temporärdateien
      des <ulink url="http://www.gnu.org/software/emacs/">GNU Emacs</ulink>
      sowie weitere gebräuchlichen temporären Dateien des Mac und
      gebräuchlicher Quellverwaltungssysteme (auch wenn Visual Source Save
      eher ein Fluch als ein Verwaltungssystem ist) ein. Sollten Ihnen diese
      Standardmuster nicht ausreichen, können Sie diese auch übersteuern, Sie
      setzen <sgmltag>useDefaultExcludes</sgmltag> auf
      <emphasis>false</emphasis> und definieren einen Satz Auschlussmuster
      innerhalb Ihres eigenen Assembly Deskriptor.</para>
    </section>

    <section id="assemblies-sect-output-algorithm">
      <title><sgmltag>Element dependencySets</sgmltag></title>

      <para>Eine der geläufigsten Anforderungen an Assemblies ist die
      Einbindung von Projektabhängigkeiten in ein Zielarchiv. Während die
      Elemente <sgmltag>file</sgmltag> und <sgmltag>fileSets</sgmltag> sich
      mit Dateien <emphasis>Ihres</emphasis> Projektes befassen, sind
      Abhängigkeiten nicht an einen Ort innerhalb Ihres Projektes gebunden.
      Artefakte von welchen ein Projekt abhängig ist, müssen während des
      Buildlaufes aufgelöst werden. Artefakte aus Abhängigkeiten sind
      abstrakt, sie haben keinen bestimmten Ort und werden mittels einem Satz
      symbolischer Koordinaten referenziert. Die Elemente
      <sgmltag>file</sgmltag> und <sgmltag>fileSets</sgmltag> benötigen in der
      Spezifikation einen konkreten Quellpfad, Abhängigkeiten hingegen werden
      durch eine Kombination von Maven Koordinaten und
      Abhängigkeits-Gültigkeitsbereichen in ein Assembly eingebunden oder
      ausgeschlossen.</para>

      <para>Das einfachste Element <sgmltag>dependencySet</sgmltag> ist ein
      leeres Element:</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet/&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

      <para>Das oben ausgeführte <sgmltag>dependencySet</sgmltag> wird allen
      Laufzeitabhängigkeiten Ihres Projektes Rechnung tragen (der
      Gültigkeitsbereich Laufzeit schliesst den von Compile implizit ein.) und
      wird die entsprechenden Abhängigkeiten Ihrem Wurzelverzeichnis des
      Zielarchivs zufügen. Darüberhinaus wird es den Projekt-Hauptartefakt, so
      dieser vorhanden ist, in das Wurzelverzeichnis kopieren.</para>

      <note>
        <para>Einen Moment! Wie Sie bemerkt haben befasst sich das Element
        <sgmltag>dependencySet</sgmltag> mit den Projektabhängigkeiten, nicht
        mit dem entsprechenden Zielarchiv? Dieser eher widersinnige
        Nebeneffekt war ein häufig ausgenutzter Fehler der Version 2.1 des
        Assembly Plugin, und da Maven Rückwärtskompatibilität gross schreibt,
        musste dieses fehlerhafte und widersinnige Verhalten zwischen Version
        2.1 und 2.2 erhalten bleiben. Sie können dieses Verhalten über die
        Einstellung <sgmltag>useProjectArtifact</sgmltag> bestimmen.</para>
      </note>

      <para>Obschon das Standardset der Abhängigkeiten ohne weitere
      Konfigurationen sehr nützlich sein kann, erlaubt dieser Abschnitt des
      Assembly Deskriptors eine breite Vielfalt möglicher Einstellungen. Dies
      erlaubt es Ihnen das Verhalten Ihren speziellen Bedürfnissen anzupassen.
      Zum Beispiel mag das Erste was Sie am Set der Abhängigkeiten anpassen
      wollen sein, den aktuellen Projektartefakten auszuschliessen. Sie tun
      dies, indem Sie die Einstellung <sgmltag>useProjectArtifact</sgmltag>
      auf <emphasis>false</emphasis> setzen (aus Gründen der
      Rückwärtskompatibilität ist der Standardwert <emphasis>true</emphasis>).
      Diese Einstellung erlaubt es Ihnen die Buildlauf Ausgabe unabhängig von
      den Abhängigkeiten zu definieren. Andererseits könnte es sein, dass Sie
      sich dafür entscheiden, die Artefakte der Abhängigkeiten entpackt
      abzulegen. Sie tun dies indem Sie die "unpack" Einstellung auf
      <emphasis>true</emphasis> setzen (Standardwert:
      <emphasis>false</emphasis>). Ist unpack auf <emphasis>true</emphasis>
      gesetzt, so wird das Assembly Plugin die Inhalte aller Artefakte der
      Abhängigkeiten dem Wurzelverzeichnis des Zielarchivs hinzufügen.</para>

      <para>Von diesem Punkt an wird es mehrere Möglichkeiten geben was Sie
      mit Ihrem Set von Abhängigkeiten anstellen wollen. Die folgenden
      Abschnitte beschreiben wie Sie die Ausgabelokation der
      <varname>dependencySets</varname> definieren, sowie Ein- und Auschluss
      von Abhängigkeiten nach Gültigkeitsbereich festlegen. Zum Schluss werden
      wir noch einmal zur Entpackfunktionalität zurückkehren und einige der
      erweiterten Möglichkeiten beim entpacken von Abhängigkeiten
      ansehen.</para>

      <section id="assemblies-sect-output-location">
        <title>Anpassen des Ausgabeortes bei Abhängigkeiten</title>

        <para>Es bestehen zwei Möglichkeiten welche in Kombination eingesetzt
        werden, um den Ort einer Abhängigkeit innerhalb eines Assemblies zu
        definieren: die Elemente <sgmltag>outputDirectory</sgmltag> und
        <sgmltag>outputFileNameMapping</sgmltag>. Es kann sein, dass Sie den
        Ort der Ablage der Abhängigkeiten innerhalb Ihres Assemblies direkt
        durch Einstellungen an den Abhängigkeiten selbst bestimmen möchten.
        Nehmen wir an, Sie möchten alle Abhängigkeiten in einem Verzeichnis
        welches der <varname>groupId</varname> des Artefakten entspricht,
        ablegen. In diesem Fall würden Sie das Unterelement
        <sgmltag>outputDirectory</sgmltag> des Elements dependencySet nutzen,
        und einen Eintrag wie folgenden vornehmen:</para>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;\${artifact.groupId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

        <para>Der aufgeführte Eintrag würde dazu führen, dass jede einzelne
        Abhängigkeit in einem Unterverzeichnis abgelegt wird, welches den
        Namen der Artefakt <varname>groupId</varname> trägt.</para>

        <para>Sollten Sie weitere Anpassungen vornehmen wollen, zum Beispiel
        der Entfernung der Versionsbezeichnung im Namen aller Abhängigkeiten,
        können Sie für jede Abhängigkeit den Eintrag für den Ausgabename
        mittels dem Element <sgmltag>outputFileNameMapping</sgmltag> wie folgt
        bestimmen:</para>

        <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;\${artifact.groupId}&lt;/outputDirectory&gt;
      &lt;outputFileNameMapping&gt;
        \${artifact.artifactId}.\${artifact.extension} 
      &lt;/outputFileNameMapping&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>

        <para>Im vorausgehenden Beispiel würde eine Abhängigkeit von
        <varname>commons:commons-codec</varname> version 1.3 in der Datei
        <filename>commons/commons-codec.jar</filename> abgelegt.</para>
      </section>

      <section id="assemblies-sect-interpolate">
        <title>Auswertung von Properties bezüglich der Ausgabelokation von
        Abhängigkeiten</title>

        <para>Wie bereits zuvor erwänt, werden die beiden Elemente
        <varname>outputDirectory</varname> und
        <varname>outputFileNameMapping</varname> nicht mit dem Rest des
        Assembly Deskriptors ausgewertet. Deren Rohwerte werden mittels
        zusätzlicher, Artefakt spezifischer Ausdrucks Prozessoren
        verarbeitet.</para>

        <para>Die möglichen Artefaktausdrücke der zwei Elemente unterscheiden
        sich nur wenig. In beiden Fällen, sind alle Ausdrucksformen im Stil
        von <varname>\${project.*}</varname>, <varname>\${pom.*}</varname>,
        und <varname>\${*}</varname> welche innerhalb eines POM sowie des
        übrigen Assembly Deskriptors zur Verfügung stehen hier ebenfalls
        einzusetzen.</para>

        <para>Für das Element <sgmltag>outputFileNameMapping</sgmltag> wird
        der folgende Prozess zur Auswertung eines Ausdrucks angewandt:</para>

        <orderedlist>
          <listitem>
            <para>Sollte der Ausdruck mit dem Muster
            <varname>\${artifact.*}</varname> übereinstimmen:</para>

            <orderedlist numeration="loweralpha">
              <listitem>
                <para>Abgleich gegen eine Instanz des Artefakts der
                Abhäniggkeit (löst: <varname>groupId</varname>,
                <varname>artifactId</varname>, <varname>version</varname>,
                <varname>baseVersion</varname>, <varname>scope</varname>,
                <varname>classifier</varname>, und <varname>file.*</varname>
                -Ausdrücke auf)</para>
              </listitem>

              <listitem>
                <para>Abgleich gegen eine Instanz des
                <classname>ArtifactHandler</classname> der Abhängigkeit (löst
                Ausdrücke auf)</para>
              </listitem>

              <listitem>
                <para>Abgleich gegen eine Instanz des Projektes welche mit der
                Abhängigkeit assoziiert ist (löst hauptsächlich POM Properties
                auf)</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>Sollte der Ausdruck mit dem Muster
            <varname>\${pom.*}</varname> or <varname>\${project.*}</varname>
            übereinstimmen:</para>

            <orderedlist numeration="loweralpha">
              <listitem>
                <para>Abgleich gegen die Instanz des Projektes
                (<classname>MavenProject</classname>) des aktuellen
                Buildlauf</para>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>Sollte der Ausdruck dem Muster
            <varname>\${dashClassifier?}</varname> entspreche und die Artefakt
            Instanz enthält eine classifier-Koordinate welche nicht null ist,
            löst dies auf eine classifier-Koordinate mit vorangestelltem
            Bindestrich auf (-classifier), andernfalls zu einem
            Leerstring.</para>
          </listitem>

          <listitem>
            <para>Versuche den Ausdruck gegen eine Projektinstanz des
            aktuellen Buildlauf abzugleichen.</para>
          </listitem>

          <listitem>
            <para>Versuche den Ausdruck gegen die <acronym>POM</acronym>
            Properties des aktuellen Buildlauf abzugleichen.</para>
          </listitem>

          <listitem>
            <para>Versuche den Ausdruck gegen die verfügbaren
            System-Properties abzugleichen</para>
          </listitem>

          <listitem>
            <para>Versuche den Ausdruck gegen die verfügbaren Betriebssystem
            Umgebungsvariablen abzugleichen</para>
          </listitem>
        </orderedlist>

        <para>Das Element <sgmltag>outputDirectory</sgmltag> wird in gleicher
        Weise abgearbeitet, der einzige Unterschied ist, dass es keine
        verfügbaren Informationen der Art <varname>\${artifact.*}</varname>
        gibt, lediglich die <varname>\${project.*}</varname> Instanz des
        entsprechenden Artefakts. Daher sind auch die Ausdrücke welche oben
        aufgeführt wurden und von diesen Klassen abhängig sind nicht verfügbar
        (1a, 1b und 3 der obigen Auflistung).</para>

        <para>Wie weiss man wann es sinvoll ist die Elemente
        <sgmltag>outputDirectory</sgmltag> und
        <sgmltag>outputFileNameMapping</sgmltag> zu benutzen? Sobald
        Abhängigkeiten entpackt werden, wird nur das
        <sgmltag>outputDirectory</sgmltag> zur berechnung der Ausgabelokation
        herangezogen. Im Fall dass Abhängigkeiten als ganze Datei (nicht
        entpackt) verwaltet werden, können beide Elemente
        <sgmltag>outputDirectory</sgmltag> und
        <sgmltag>outputFileNameMapping</sgmltag> eingesetzt werden. Werden die
        Elemente gemeinsam genutzt, so ist das Resulat gleichbedeutend
        mit:</para>

        <programlisting language="xml">&lt;archive-root-dir&gt;/&lt;outputDirectory&gt;/&lt;outputFileNameMapping&gt;</programlisting>

        <para>Sollte <sgmltag>outputDirectory</sgmltag> fehlen, so wird es
        nicht angezogen, sollte <sgmltag>outputFileNameMapping</sgmltag>
        fehlen, so ist der Standardwert:
        <code>\${artifact.artifactId}-\${artifact.version}\${dashClassifier?}.\${artifact.extension}</code></para>
      </section>

      <section id="assemblies-sect-include-by-scope">
        <title>Ein- und Auschluss von Abhängigkeiten in Relation zum
        Gültigkeitsbereich</title>

        <para>Im Abschnitt <xref
        linkend="pom-relationships-sect-project-dependencies" /> wurde
        ausgeführt wie jede Abhängigkeit dem einen oder anderen
        Gültigkeitsbereich zugeordnet ist. Der Gültigkeitsbereich bestimmt,
        wann innerhalb eines Buildprozesses eine Abhängigkeit zum Einsatz
        kommt. So sind Abhängigkeiten vom Gültigkeitsbereich
        <varname>test</varname> nicht Teil des Klassenpfades zum Zeitpunkt der
        Kompilation der (Haupt-)Klassen, werden aber zur Kompilation der
        Testklassen dem Klassenpfad angefügt. Dies ist so, da Ihre Projekt
        Quellen keinen testspezifischen Code enthalten sollen, da das Testen
        keine Funktion des Projektes ist (es stellt eine Funktion des Projekt
        Build Prozesses dar). In gleicher Weise wird davon ausgegangen, dass
        Abhängigkeiten des Gültigkeitsbereich <varname>provided</varname> in
        der Zielumgebung vorhanden sind. Es ist jedoch so, dass, sollte ein
        Projekt eine Abhängigkeit des Gültigkeitsbereich
        <varname>provided</varname> besitzen, diese bereits während des
        Buildvorangs benötigt wird um zu kompilieren. Daher sind derartige
        Abhängigkeiten zwar dem Klassenpfad hinzugefügt, nicht jedoch Teil der
        Artefakte welche mit dem Projekt oder dem Projektassembly gebündelt
        werden.</para>

        <para>Im gleichen Kapitel wird ebenfalls ausgeführt, dass manche
        Gültigkeitsbereiche andere stillschweigend voraussetzen. Ein Beispiel
        ist der Gültigkeitsbereich <varname>runtime</varname>, der
        stillschweigend den Gültigkeitsbereich <varname>compile</varname>
        voraussetzt, da alle Abhängigkeiten zur Zeit der Kompilierung (mit
        Ausnahme der des Gültigkeitsbereichs <varname>provided</varname>) zur
        Ausführng notwendig sind. Es gibt hierbei eine Anzahl komplexer
        Beziehungen zwischen den verschiedenen Gültigkeitsbereichen welche
        bestimmen wie der Gültigkeitsbereich einer
        <emphasis>direkten</emphasis> Abhängigkeit den Gültigkeitsbereich
        einer <emphasis>transitiven</emphasis> Abhängigkeit beeinflusst. In
        einem Maven Assembly Deskriptor können wir daher entsprechend der
        verschiedenen Gültigkeitsbereiche den Abhängigkeiten unterschiedliche
        Einstellungen zuordnen.</para>

        <para>Ein Beispiel: planen wir eine Webanwendung zusammen mit Jetty zu
        bündeln um eine abgeschlossene Anwendung zu erstellen, so müssen wir
        alle Abhängigkeiten vom Gültigkeitsbereich
        <emphasis>provided</emphasis> in der Verzeichnisstruktur von Jetty
        ablegen, welche eingeschlossen werden sollen. Somit werden diese
        "bereitgestellten" Abhängigkeiten auch der Runtime-Umgebung zur
        Verfügung gestellt. Hierbei nicht bereitgestellte Abhängigkeiten vom
        Gültigkeitsbereich <emphasis>runtime</emphasis> werden weiterhin im
        Verzeichnis WEB-INF/lib landen, was erzwingt, dass diese beiden
        Abhängigkeits Sätze getrennt verarbeitet werden müssen. Die Defiition
        dieser zwei Abhängigkeits Sätze könnte wie der folgende Ausschnitt
        eines XML Dokuments aussehen:</para>

        <example>
          <title>Erstellen von Abhängigkeitsgruppen mittels
          Gültigkeitsbereichen</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;outputDirectory&gt;lib/\${project.artifactId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/WEB-INF/lib
      &lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Abhängigkeiten des Gültigkeitsbereichs
        <emphasis>provided</emphasis> werden dem Verzeichnis
        <filename>/lib</filename> des Ursprungsverzeichnis hinzugefügt, von
        welchem angenommen wird, dass es in den globalen Klassenpfad der Jetty
        Laufzeitumgebung aufgenommen wird. Wir verwenden hierbei ein
        Unterverzeichnis welches die ArtefactId als Namen trägt um es zu
        vereinfachen, den Ursprung einer bestimmten Bibliothek zu finden.
        Abhängigkeiten zur Laufzeit werden in das Verzeichnis
        <filename>/WEB-INF/lib</filename> der Webanwendung aufgenommen. Dieses
        befindet sich in einem der Unterverzeichnisse des Verzeichnisses
        <filename>/webapps</filename> von Jetty, welches mittels einem
        Property namens webContextName im <acronym>POM</acronym> gesetzt wird.
        Im vorausgehenden Beispiel haben wir die anwendungsspezifischen
        Abhängigkeiten von denen getrennt, welche Teil der
        Servletspezifikation sind und daher Teil des globalen
        Klassenpfades.</para>

        <para>Allerdings mag es nicht ausreichen die Abhängigkeiten nach
        Gültigkeitsbereich zu trennen, insbesondere nicht bei Webanwendungen.
        Es ist durchaus denkbar, dass eine oder mehrere Abhängigkeiten des
        Gültigkeitsbereich <emphasis>runtime</emphasis> standardisierte Bündel
        nicht kompilierter Ressoucen einer Webanwendung darstellen. Nehmen Sie
        zum Beispiel eine Anzahl Webanwendungen welche eine gemeinsame Basis
        von JavaSkript, <acronym>CSS</acronym>, <acronym>SWF</acronym> oder
        Bilddateien teilen. Um die Wiederverwendbarkeit zu unterstützen ist es
        gebräuchlich derartige Ressourcen zu bündeln und separat in das Maven
        Repository einzustellen. Von dem Punkt an ist es möglich diese
        Resourcen wie gewöhnliche Maven Abhängigkeiten - womöglich vom
        Abhängigkeitstyp zip - zu addressieren, normalerweise als Teil des
        Gültigkeitsbereich <emphasis>runtime</emphasis>. Bitte beachten Sie,
        dass es sich hierbei um Resourcen handelt, nicht binäre Abhängigkeiten
        Ihrer Quellen. Aus diesem Grund ist es nicht angebracht diese in das
        Verzeichnis <filename>/WEB-INF/lib</filename> abzulegen. Tatsächlich
        sollten derartige Archive getrennt von den Laufzeit-Binaries entpackt
        und im Wurzelverzeichnis der Webanwendung abgelegt werden. Um eine
        derartige Trennung zu erstellen ist es notwending spezielle Ein- und
        Ausschlusskriterien auf diese bestimmten Koordinaten
        anzuwenden.</para>

        <para>In anderen Worten, sollten Sie also drei oder vier
        Webanwendungen bearbeiten, welche die selben Resourcen benutzen und
        Sie möchten hierfür ein Assembly erstellen, welches Abhängigkeiten von
        Scope <emphasis>provided</emphasis> im Verzeichnis
        <filename>/lib</filename> ablegt, Abhängigkeiten vom
        Gültigkeitsbereich <emphasis>runtime</emphasis> im Verzeichnis
        <filename>/webapps/&lt;contextName&gt;/WEB-INF/lib</filename> und
        darüberhinaus gewisse Laufzeitabhängigkeiten in das
        Anwendungswurzelverzeichnis entpackt, so ist dies möglich. In einem
        Assembly steht es Ihnen frei, verschiedene ein- und Auschlusskriterien
        zu einem bestimmten Element <varname>dependencySet</varname> zu
        definieren. Der folgende Abschnitt wird dies vertiefen.</para>
      </section>

      <section id="assemblies-sect-fine-tune">
        <title>Fine Tuning: Ein- und Ausschlusskriterien für
        Abhängigkeiten</title>

        <para>Eine Abhänigkeit zu einer Resource mag ein einfaches Bündel
        Ressourcen sein (<acronym>CSS</acronym>, JavaSkript oder Grafiken),
        innerhalb eines Projektes welches ein Assembly besitzt das ein
        <acronym>ZIP</acronym> Archiv erstellt. Ausgehend von den bestimmten
        Gegebenheiten einer Webanwendung ist es uns möglich eine derartige
        Abhängigkeit zu einer Resource von einer Binärabhängigkeit der Quellen
        alleine am Typ zu unterscheiden. Die meisten Webanwendungen haben
        Abhängigkeiten vom Typ <varname>jar</varname> und so ist es möglich
        mit einiger Sicherheit zu definieren, dass Abhängigkeiten vom Typ
        <acronym>ZIP</acronym> Ressourcen darstellen. Es kommt aber auch vor,
        dass Ressourcen im <acronym>JAR</acronym>-Format auftreten und dann
        eine Klassifizierung der Art <varname>resource</varname> oder änlich
        haben. In jedem Fall ist es möglich Kriterien zu erstellen um diese
        Ressourcen herauszufiltern und getrennt von den binären Abhängigkeiten
        zu verarbeiten. Wir definieren derartige Filterkriterien in den
        Unterelementen <varname>includes</varname> sowie
        <varname>excludes</varname> des Elements
        <varname>dependencySet</varname>.</para>

        <para>Beide Unterelemente sind Auflistungsabschnitte, das bedeutet,
        dass diese die Unterelemente <varname>include</varname> und
        <varname>exclude</varname> erlauben. Jedes Element
        <varname>include</varname> (<varname>exclude</varname>) beinhaltet
        einen String welcher Jokerzeichen enthalten kann. Jeder Wert kann auf
        verschiedene Art und Weise zur Anwendung kommen. Im allgemeinen werden
        dreierlei Musterformate unterstützt:</para>

        <variablelist>
          <varlistentry>
            <term><varname>groupId:artifactId</varname> - Versionsloser
            Schlüssel</term>

            <listitem>
              <para>Sie würden dieses Muster anwenden um eine Abhängigkeit
              gestützt auf groupId und artifactId zu definieren</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><varname>groupId:artifactId:type[:classifier]</varname> -
            Konfliktschlüssel</term>

            <listitem>
              <para>Dieses Muster erlaubt es Ihnen einen breiteren Satz von
              Koordinaten zu definieren, sowie spezifischere
              Ein-/Auschlusskriterien auszudrücken.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><varname>groupId:artifactId:type[:classifier]:version</varname>
            - Genauer Artifakt Schlüssel</term>

            <listitem>
              <para>Sollten Sie die Detailgenauigkeit benötigen, so können Sie
              auch alle Koordinaten angeben.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Alle der oben genannten Musterformate unterstützen das
        Jokerzeichen "*" welches alle Bestandteile eines Schlüssels ersetzen
        kann, und ist nicht darauf angewiesen auf genau einen Bestandteil zu
        passen (Teile zwischen den Doppelpunkten ':') Beachten Sie auch, dass
        die Koordinate <varname>classifier</varname> optional ist, insofern,
        dass auf Kriterien passende Abhängigkeiten welche keinen
        Koordinatenbestandteil <varname>classifier</varname> besitzen dieser
        nicht ausgewertet wird. </para>

        <para>Im oben angegebenen Beispiel, wobei das herausragende Merkmal
        der Artifakttyp <acronym>ZIP</acronym> ist und keine der
        Abhängigkeiten einen Koordinatenbestandteil
        <varname>classifier</varname> trägt, würde das folgende Kriterium auf
        die Ressource-Abhängigkeiten passen (unter der Annahme, dass diese
        alle vom Typ <acronym>ZIP</acronym> sind):</para>

        <programlisting>*:zip</programlisting>

        <para>Das aufgeführte Kriterium benutzt die zweite Abhängigkeitsform:
        den Konfliktschlüssel der Abhängigkeit. Jetzt, da wir ein Kriterium
        gefunden haben welches uns erlaubt Resourcen von binären
        Abhängigkeiten zu trennen, können wir auch unsere Elemente
        <varname>dependencySets</varname> entsprechend anpassen um unsere
        Resource-Archive entsprechend zu verarbeiten.</para>

        <example id="ex-complex-dependencySet">
          <title>Benutzung von Abhängkeits Ein- und Ausschlüssen in
          <sgmltag>dependencySets</sgmltag></title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
      &lt;outputDirectory&gt;lib/\${project.artifactId}&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/WEB-INF/lib
      &lt;/outputDirectory&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*:zip&lt;/exclude&gt;
      &lt;/excludes&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/resources
      &lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;*:zip&lt;/include&gt;
      &lt;/includes&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Im Beispiel <xref linkend="ex-complex-dependencySet" /> wurden
        die Definition der Abhängigkeiten vom Gültigkeitsbereich
        <emphasis>runtime</emphasis> derart abgeändert, dass diese
        Ressource-Abhängigkeiten ausschliessen. Lediglich binäre
        Abhängigkeiten (Abhängigkeiten nicht vom Typ zip) sollen dem
        Verzeichnis <filename>/WEB-INF/lib</filename> der Webanwendung
        angefügt werden. Die Resource-Abhängigkeiten sind nun in einem eigenen
        Element <varname>dependencySet</varname> definiert, derart um diese
        Abhängigkeiten dem Resourcenverzeichnis der Webanwendung zuzufügen.
        Der Abschnitt <varname>includes</varname> des letzten Element
        <varname>dependencySet</varname> ist genau das Gegenteil des
        Abschnitts <varname>excludes</varname> des vorangehenden Elements
        <varname>dependencySet</varname> derart, dass Ressource-Abhängigkeiten
        mittels den selben Identitätskriterien eingeschlossen werden, z.B.
        <filename>*:zip</filename>. Das letzte Element
        <varname>dependencySet</varname> bezieht sich auf die gemeinsamen
        Resource-Abhängigkeiten welche konfiguriert sind um diese im
        Wurzelverzeichnis der Anwendung zu entpacken. </para>

        <para>Das Beispiel <xref linkend="ex-complex-dependencySet" /> beruht
        auf der Annahme, dass unsere gemeinsamen Ressource-Abhängigkeit von
        einem Typ ist, welcher sich von allen anderen Abhängigkeiten
        unterscheidet. Was würde passieren sollte dies nicht der Fall sein und
        die Ressoure-Abhängigkeit vom gleichen Typ sein wie alle anderen
        Ahängigkeiten? Wie könnte man dann die Abhängigkeit
        herausdifferenzieren? In diesem Fall, in welchem die
        Resource-Abhängigkeit ebenfalls als <acronym>JAR</acronym> mit einer
        klasssifizierenden Koordinate <varname>ressources</varname> besteht
        können Sie auf das Identitätsmuster setzen und derart die
        Abhängigkeiten bestimmen:</para>

        <programlisting>*:jar:resources</programlisting>

        <para>Anstelle der Suche nach Artefakten vom Typ
        <varname>zip</varname> ohne Berücksichtigung der klassifizierenden
        Koordinate suchen wir nun nach Artefakten mit klassifizierender
        Koordinate <varname>ressources</varname> welche vom Typ
        <varname>jar</varname> sind.</para>

        <para>Wie bereits im Abschnitt über <varname>fileSets</varname>
        beschrieben, unterstützen <varname>dependencySets</varname> ebenfalls
        die Einstellung <varname>useStrictFiltering</varname>. Sollte diese
        zugeschaltet sein, wird jedes ausgewiesene Kriterium welches nicht
        mindestens eine passende Abhängigkeit findet einen Fehler ausweisen
        und die Erstellung des Assembly und damit die Ausführung des Buildes
        abbrechen. Dies kann insbesondere als nützliches Sicherheitsventil zum
        Einsatz kommen: um sicherzustellen, dass Abhängigkeiten von Projekten
        mit dem entsprechenden Assembly Deskriptor synchronisiert sind und so
        zusammenspielen wie Sie sich das vorgestellt haben. Standardmässig ist
        die Eingenschaft auf <varname>false</varname> gesetzt, schon alleine
        wegen der Rückwärtskompatibilität.</para>
      </section>

      <section id="assemblies-sect-transitive">
        <title>Transitive Abhängigkeiten, Projekt Anhänge, und Projekt
        Artefakte</title>

        <para>Der Abschnitt <varname>dependencySet</varname> unterstützt zwei
        weitere generelle Mechanismen zur Bestimmung der Untermenge von
        Artefakten: Transitive Auswahlgruppen und Optionen, um mit
        Projektartefakten zu arbeiten. Diese beiden Mechanismen sind aus der
        Notwendigkeit heraus entstanden frühere Konfigurationen zu
        unterstützen, welche eine freiere Definition des Wortes "Abhängigkeit"
        zugrunde legten. Für ein gutes Beispiel, sehen Sie sich den
        Hauptartefakten eines Projektes an. Typischerweise würde dieser nicht
        als Abhängigkeit gesehen, jedoch schlossen frühere Versionen des
        Assembly Plugin diesen Artefakt in die Berechnung der Abhängigkeiten
        ein. Um zu diesem Verhalten Rückwärtskompatibilität zu bieten
        unterstützt die Version 2.2 (derzeit 2.2-beta-2) des Assembly Plugin
        eine Einstellung <varname>useProjectArtifact</varname> dessen
        Standardwert auf <varname>true</varname> gesetzt ist. Standardmässig
        wird bei der Berechnung der Abhängigkeiten versucht werden, den
        Hauptartefakt in die Bestimmung der passenden Artefakte,
        einzuschliessen. Sollten Sie es vorziehen sich mit dem Hauptartefakten
        direkt zu befassen, so setzen Sie diese Einstellung auf
        <varname>false</varname>.</para>

        <tip>
          <para>Die Authoren dieses Buches empfehlen, dass Sie
          <varname>useProjektArtefacts</varname> immer auf
          <varname>false</varname> setzen.</para>
        </tip>

        <para>Eine der natürlichen Erweiterungen zum Einschluss des
        Projekthauptartefakten ist die Möglichkeit die dem Projekt
        angeschlossenen Artefakte ebenfalls innerhalb eines Elements
        <varname>dependencySet</varname> zu verwalten. Um dies zu tun, setzen
        Sie die Einstellung <varname>useProjectAttachments</varname> (deren
        Standardeinstellung <varname>false</varname> ist) um. Die Freigabe
        dieser Einstellung erlaubt Muster und Kriterien, welche die
        klassifizierende Koordinate und den Typ eines Artefaktes untersuchen,
        auch auf Artefakte anzuwenden, welche dem Hauptprojekt angehängt sind.
        Das bedeutet, diese teilen sich die Hauptkoordinaten
        <varname>groupId</varname>, <varname>artifactId</varname> und
        <varname>version</varname>, unterscheiden sich aber im
        <varname>type</varname> und/oder klassifizierender Koordinate vom
        entsprechenden Hauptartefakten. Dies ist insbesondere nützlich sollten
        JavaDoc oder Quellen in einem Assembly verarbeitet werden.</para>

        <para>Über die Verarbeitung der Projektartefakte hinaus gibt es die
        Möglichkeit die entsprechenden <varname>dependencySets</varname>
        mittels zweier Einstellungen bezüglich transitiver Auflösung zu
        beeinflussen. Die erste Einstellung trägt den Namen
        <varname>useTransitiveDependencies</varname> (ist standardmässig auf
        <varname>true</varname> gesetzt) und bestimmt, wie zu erwarten, ob
        transitive Abhängigkeiten bei der Berechnung der Abhängigkeitssets
        überhaupt berücksichtigt werden sollen. Um aufzuzeigen wie diese
        Einstellung zu benutzen ist, stellen Sie sich vor, Ihr
        <acronym>POM</acronym> hätte eine Abhängigkeit zu einem weiteren
        Assembly. Das Assembly wird (höchstwarscheinlich) eine
        klassifizierende Koordinate besitzen, welche sich von der des
        Haupartefaktes unterscheidet, womit der Artefakt dem Projekt angehängt
        wird. Eine Eigenart des Maven Abhängigkeiten Auflösungsprozesses ist
        jedoch, dass transitive Abhängigkeitsinformationen des Hauptartefakten
        bei der Auflösung des Assembly Artefakten zum Zug kommen. Bündelt das
        Assembly also Abhängigkeiten des Projektes in sich selbst, führt der
        Einsatz von transitiver Abhängigkeitsauflösung unweigerlich zu einer
        Verdopplung dieser Abhängigkeiten. Um dies zu verhindern, setzen Sie
        einfach die Einstellung <varname>useTransitivDependencies</varname>
        auf <varname>false</varname>, für das Element
        <varname>dependencySet</varname> welches diese Assembly Abhängigkeit
        verarbeitet.</para>

        <para>Die zweite Einstellung bezüglich transitiver Abhängikeiten ist
        bedeutend subtiler: Diese trägt den Namen
        <varname>useTransitivFiltering</varname> und ist standardmässig auf
        <varname>false</varname> gesetzt. Um zu verstehen, was diese
        Einstellung ermöglicht, ist es wichtig zu verstehen, welche
        Informationen überhaupt dem Abhängigkeits-Auflösungs-Prozess zur
        Verfügung stehen. Sollte ein Artefakt eine Abhängigkeit zu einer
        Abhängigkeit sein, besitzt es, was in Maven als
        <varname>DependencyTrail</varname> (AbhängigkeitsSpur) bezeichnet
        wird. Diese wird als Liste von Strings vorgehalten, welche jeweils die
        vollständige Artefakt Identität
        (groupId:artifactId:type:[classifier:]version) aller Artefakte
        zwischen Ihrem <acronym>POM</acronym> und dem den
        <varname>DependencyTrail</varname> besitzenden Artefakten besteht. Mit
        Rückblick auf die drei zur Verfügung stehenden Möglichkeiten der
        Kriterienanwendung auf eine Bündel Abhängigkeiten wird Ihnen
        auffallen, dass die Einträge in einem
        <varname>DependencyTrail</varname> - die vollständige Artefakt
        Identität - dem dritten Typus entsprechen. Sollte die Einstellung
        <varname>useTransitivefilterung</varname> zugeschaltet sein, so können
        die Einträge der Abhängigkeitsspur des Artefakten in gleicher Weise zu
        einem Treffer führen wie die Identität des Artefakten selbst.</para>

        <para>Sollten Sie also die transitive Filterung in Betracht ziehen, so
        raten wir Ihnen, auf der Hut zu sein. Ein Artefakt kann von
        unterschiedlichen Abhängigkeiten mehrmals in eine Bündel
        Abhängigkeiten eingeschlossen werden, erst mit Version 2.0.9 wird dies
        beschränkt und nur der erste Treffer dieser Art der Suche
        berücksichtigt. Dies wiederum kann zu feinsinnigen Problemen bei der
        Erstellung eines Satzes Abhängigkeiten zu Ihrem Projekt führen.</para>

        <warning>
          <para>Die allermeisten Assemblies benötigen keine derartig
          feingranulare Kontrolle des Satzes der Abhängigkeiten; wägen Sie
          genau ab, ob es wirklich gebraucht wird. Ein Tip: warscheinlich
          nicht.</para>
        </warning>
      </section>

      <section id="assemblies-sect-unpack">
        <title>Fortgeschrittene Entpackoptionen</title>

        <para>Wie zuvor bereits erwähnt ist es in einigen Fällen notwendig
        eine Abhängigkeit zu entpacken, um ein funktionsfähiges Assembly zu
        erstellen. Im vorausgegangenen Beispiel war die Entscheidung hierfür
        einfach. Das Beispiel hat nicht berücksichtigt was entpackt werden
        muss, und noch weniger was nicht entpackt werden sollte. Um über das
        Entpacken der Abhängigkeiten eine grössere Kontrolle auszuüben, können
        Sie das Unterelement <varname>unpackOptions</varname> des Elements
        <varname>dependencySet</varname> setzen. Mittels diesem Abschnitt
        haben Sie die Möglichkeit über Ein- und Auschlussmuster Dateien des
        Assemblies zu bestimmen, sowie festzulegen, ob diese Dateien auf
        Ausdrücke auf der Basis der aktuellen <acronym>POM</acronym>
        Informationen gefiltert werden sollen. Tatsächlich sind die zur
        Verfügung stehenden Optionen, welche zum Entpacken von
        Abhängigkeitssätzen bereitstehen, ganz ähnlich denen welche zur
        Auswahl von Dateien aus der Projektverzeichnisstruktur mit Hilfe der
        <varname>fileSet</varname> Deskriptoren bestehen.</para>

        <para>Um an unser Webanwendungs-Beispiel anzuknüpfen, nehmen Sie
        einmal an, eine der Ressource-Abhängigkeiten wurden mit einer Datei
        gebündelt welche deren Verbreitungslizenz darstellt. Im Falle unserer
        Webanwendung werden wir diese 3rd Party Lizenzen mittels einer Datei
        <filename>NOTICES</filename> in unser Projektbündel einschliessen,
        womit wir verhindern wollen, dass die Lizenz eines Ressource Bündels
        zusätzlich eingeschlossen wird. Um diese Datei auszuschliessen, fügen
        wir lediglich eine unpack-Option in das
        <varname>DependencySet</varname> ein, welches die folgenden
        Ressource-Artefakten verarbeitet:</para>

        <example>
          <title>Ausschliesen von Dateien von einem Abhängigkeits Unpack
          Bündel</title>

          <programlisting language="xml">&lt;asembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;outputDirectory&gt;
        webapps/\${webContextName}/resources
      &lt;/outputDirectory&gt;
      &lt;includes&gt;
        &lt;include&gt;*:zip&lt;/include&gt;
      &lt;/includes&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
      &lt;unpackOptions&gt;
        &lt;excludes&gt;
          &lt;exclude&gt;**/LICENSE*&lt;/exclude&gt;
        &lt;/excludes&gt;
      &lt;/unpackOptions&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Beachten Sie, dass das Ausschlusskriterium welches wir benutzen,
        denen in der <varname>fileSet</varname>-Beschreibung sehr ähnlich ist.
        Hierbei sperren wir jegliche Datei welche mit dem Wort
        <filename>LICENSE</filename> anfängt in jedem Verzeichnis des
        Resorce-Artefaktes. Stellen Sie sich die Unpackoptionen wie eine Art
        fileSet-light vor, welche auf jede Abhängigkeit innerhalb eines
        Abhängigkeitsbündels angewandt wird. In anderen Worten, es stellt eine
        Art <varname>fileSet</varname> einer entpackten Abhängigkeit dar.
        Genau wie wir ein Auschlussmuster auf Dateien innerhalb einer
        Resource-Abhängigkeit definieren konnten um bestimmte Dateien
        auszuschliessen, können Sie derart festlegen, welchen Satz von Dateien
        Sie mittels dem Abschnitt <varname>includes</varname> einschliessen
        wollen. Die gleiche Implementierung welche bei der Bearbeitung von
        Ein- und Ausschlusskriterien auf fileSets zum Zug kommt wurde zur
        Verarbeitung von <varname>unpackOptions</varname>
        wiederverwendet.</para>

        <para>Zusätzlich zu den Ein- und Ausschlüssen von Dateien bieten die
        <varname>unpackOptions</varname> eines Abhängigkeitsbündels auch noch
        eine Einstellung <varname>filtering</varname>, deren Standardwert
        <varname>false</varname> ist. Auch diese Option wird Ihnen, gestützt
        auf die vorhergehenden Abschnitte, bekannt vorkommen. In beiden Fällen
        werden Maven-Ausdrücke der Art <varname>\${property}</varname> oder in
        Ant-Syntax von <filename><varname>@property@</varname></filename>
        unterstützt.Auf Dependency-Bündel angewandt, ist Filterung eine
        besonders angenehme Eigenschaft, da dies Ihnen erlaubt,
        standardisierte, versionierte Resource-Vorlagen zu erzeugen, welche
        erst mit der Einbindung in ein Assembly angepasst werden. Sobald Sie
        den Einsatz von entpackten, gefilterten Resource-Bündeln, welche
        gemeinsam abgelegte Resourcen darstellen, gemeistert haben, sind Sie
        auch in der Lage, wiederholt zum Einsatz kommende Resourcen
        herauszuabstrahieren.</para>
      </section>

      <section id="assemblies-sect-summarizing">
        <title>Zusammenfassung von Abhängigkeitsbündeln</title>

        <para>Schliesslich soll nicht unerwähnt bleiben, dass
        <varname>dependencySets</varname> die gleichen Konfigurationen
        <varname>fileMode</varname> und <varname>directoryMode</varname> wie
        fileSets, bereitstellen. Bedenken Sie aber, dass
        <varname>directoryMode</varname> Einstellungen nur zum Zug kommen,
        sollte die Abhängigkeit entpackt sein.</para>
      </section>
    </section>

    <section id="assemblies-sect-modulesets">
      <title><sgmltag>Element moduleSets</sgmltag></title>

      <para>Multi modulare Builds werden im allgemeinen durch das
      übergeordnete <acronym>POM</acronym> sowie den Module-Abschnitten der in
      Wechselbeziehungen stehenden <acronym>POM</acronym>s zusammengehalten.
      Gewöhnlich werden die untergeordneten Module in den entsprechenden
      Module Abschnitten der <acronym>POM</acronym> definiert, was diese in
      den Build Prozess des übergeordneten <acronym>POM</acronym>
      einschliesst. Wie genau diese Beziehung definiert ist, ist von Bedeutung
      wenn es darum geht, wie das Assembly Plugin an diesem Prozess teilhaben
      kann. Wir werden dies später genauer beleuchten. Zu diesem Zeitpunkt
      reicht es, sich das Beziehungsmodell wie es unter
      <varname>moduleSets</varname> beschrieben ist, zu betrachten.</para>

      <para>Projekte werden zu multi-modularen Buildläufen zusammengestrickt,
      da sie Teil eines grösseren Systems sind. Diese Projekte sind darauf
      ausgelegt, zusammen zum Einsatz zu kommen, und so macht ein einzelnes
      Module eines grösseren Build Laufes nicht viel Sinn. Die Struktur des
      Projekts ist davon bestimmt wie wir erwarten, dass das Projekt (und
      dessen Module) zum Einsatz kommen. Betrachten wir ein Projekt von der
      Warte eines Benutzers, so macht es Sinn, dass das Endziel eines
      Buildlaufes eine einzige zu verteilende Datei ist (Distribution), welche
      ohne grössere Installationsprobleme konsumiert werden kann. Da
      multi-modulare Maven Builds gewönlich eine hierarchische Struktur
      aufweisen, in welcher Informationen bezüglich Abhängigkeiten, Plugin
      Konfigurationen und weitere Informationen von oben nach unten vererbt
      werden, so erscheint es natürlich, dass die Aufgabe alle Module in ein
      grosses Ganzes zusammen zu fügen dem allerobersten Projekt zufällt. Dies
      ist der Ort an welchem <varname>moduleSet</varname> in Spiel
      kommen.</para>

      <para><varname>molduleSets</varname> erlauben den Einschluss von
      Ressourcen in die endgültige Zusammenstellung (Assembly) welche zu
      beliebigen Modulen der Projektstruktur gehören. Genau wie Sie eine
      Anzahl Dateien zum Einschluss in ein Assembly mittels
      <varname>fileSets</varname> und <varname>dependencySets</varname>
      auswählen können, so können Sie die Auswahle von Datein und Ressourcen
      mittels <varname>moduleSets</varname> bestimmen, um hierbei auf
      beliebige Module eines multi-modularen Builds zuzugreifen. Dies wird
      durch zwei spezifische Möglichkeiten der modulspezifischen Auswahl
      erreicht: Datei-basierend sowie Artefact-basierend. Vor wir nun die
      Details und Unterschiede zwischen diesen Möglichkeiten ausführen, lassen
      Sie uns aufzeigen wie die zu verarbeitenden Module ausgewählt
      werden.</para>

      <section id="assemblies-sect-module-selection">
        <title>Modulauswahl</title>

        <para>Zu diesem Zeitpunkt sind Sie bereits zu gut eingeführt in die
        Ein-und Ausschlusskriterien wie diese innerhalb des gesamten Assembly
        Deskriptors zur Anwendung kommen. Sobald Sie sich innerhalb eines
        Assembly Deskriptors auf Module beziehen werden Sie diese
        Ein-/Ausschlussmuster benutzen um diesbezüglich Regeln zu erstellen.
        Der grosse Unterschied bei modulbezogenen Regeln ist, dass diese keine
        Joker beinhalten können. (Seit Version 2.2-beta-2 hat diese
        Eigenschaft nur wenig Interesse gelockt, und daher die Implementierung
        nicht weiter verfolgt. Statt dessen besteht jegliches
        Ein-/Auschlussmuster einfach aus der entsprechenden
        <varname>groupId</varname> sowie die durch einen Doppelpunkt getrennte
        <varname>artifactId</varname> des Moduls:</para>

        <programlisting>groupId:artifactId</programlisting>

        <para>Zusätzlich zu den Ein- und Ausschlusskriterien unterstützt das
        <varname>modulSet</varname> eine weitere Auswahl: die Einstellung
        <varname>includeSubModules</varname> (dessen Wert auf
        <varname>true</varname> gesetzt ist). Die Hierarchieordnung eines
        multi-modularen Builds ist nicht auf zwei Ebenen eines Projektes
        begrenzt. Tatsächlich können Sie eine beliebige Anzahl
        Hierarchieebenen in Ihren Build einschliessen. Jedes Projekt, welches
        ein Modul zu einem Modul Ihres Projektes darstellt wird als Submodul
        gesehen. Zeitweise werden Sie jedes Modul einzeln abhandeln wollen
        (einschliesslich der zugehörigen Untermodule). Ein Beispiel: es
        vereinfacht die Erstellung von Artefakt-basierenden Beiträgen aus den
        Modulen. Um diese zu erstellen belassen Sie die Einstellung
        <varname>useSubModules</varname> auf true.</para>

        <para>Sollten Sie versuchen Dateien von allen Verzeichnisstrukturen
        der Module einzuschliessen, so macht es Sinn die Verzeichnisstruktur
        nur ein einziges Mal zu bearbeiten. Sollte Ihre
        Projektverzeichnisstruktur also die oberste Struktur der Hierarchie,
        welche im <acronym>POM</acronym> enthalten ist, abbilden, so würde
        dies zu Auswahlkriterien der Art <filename>**/src/main/java</filename>
        führen, welche nicht nur auf das beabsichtigete Modul Anwendung
        findet, sondern auf die gesamte Hierarchie. Tatsächlich wollen Sie in
        diesem Fall nur die erste Stufe der Hierarchie und nicht den ganzen
        Baum bearbeiten; dieser wird als Unterverzeichnis zu Ihrem Projekt
        bereits bearbeitet. In einem solchen Fall werden Sie die Untermodule
        getrennt bearbeiten wollen und daher die Einstellung
        <varname>useSubModules</varname> auf <varname>false</varname>
        setzen.</para>

        <para>Sobald Sie nun festgelegt haben wie die Modulauswahl für das
        entsprechende <varname>moduleSet</varname> stattfinden soll, so sind
        wir bereit zu definieren was aus den entsprechenden Modulen
        eingeschlossen werden soll. Wie bereits beschrieben kann dies Dateien
        oder Artefakten des Modul Projektes umfassen.</para>
      </section>

      <section id="assemblies-sect-sources-section">
        <title>Element sources</title>

        <para>Nehmen Sie einmal an, Sie wollen die Quellen der Module Ihres
        Projektes in ihr Assembly einschliessen, aber ein bestimmtes Modul
        davon auschliessen. Vielleicht bearbeiten Sie ein Projekt namens
        GeheimeSosse welche ein Geheimnis, ein sSück heiklen Code beinhaltet
        welchen Sie nicht mit Ihrem Projekt weitergeben wollen. Der einfachste
        Weg dies zu erreichen ist es ein <varname>moduleSet</varname>
        einzusetzen, welches alle Projektverzeichnisse in
        <varname>\${module.basedir.name}</varname> einschliest aber das Modul
        GeheimeSosse davon ausschliesst. Bei der anschliessenden Bearbeitung
        des <varname>moduleSet</varname> wird das entsprechende Modul vom
        Assembly ausgeschlossen. </para>

        <example id="ex-include-exclude-moduleSet">
          <title>Ein- und Ausschluss von Modulen mittels einem a
          <sgmltag>moduleSet</sgmltag></title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;includeSubModules&gt;false&lt;/includeSubModules&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;
          com.mycompany.application:secret-sauce
        &lt;/exclude&gt;
      &lt;/excludes&gt;
      &lt;sources&gt;
        &lt;outputDirectoryMapping&gt;
          \${module.basedir.name}
        &lt;/outputDirectoryMapping&gt;
        &lt;excludeSubModuleDirectories&gt;
          false
        &lt;/excludeSubModuleDirectories&gt;
        &lt;fileSets&gt;
          &lt;fileSet&gt;
            &lt;directory&gt;/&lt;/directory&gt;
            &lt;excludes&gt;
              &lt;exclude&gt;**/target&lt;/exclude&gt;
            &lt;/excludes&gt;
          &lt;/fileSet&gt;
        &lt;/fileSets&gt;
      &lt;/sources&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Im Beispiel <xref linkend="ex-include-exclude-moduleSet" />
        stellen wir die Einstellung <varname>includeSubModules</varname> auf
        <varname>false</varname>. Das vereinfacht uns die Handhabe indem wir
        uns auf die direkten Untermodule beschränken, da wir alle Quellen des
        Projektes bearbeiten und somit Joker auf das fileSet einsetzen können.
        Die Einstellung bewahrt uns davor, uns damit befassen zu müssen, dass
        tieferliegende Untermodule ebenfalls in das Assembly Archiv
        eingebunden werden. Das Element <varname>exclude</varname> befasst
        sich mit dem Modul geheimeSauce. Wir werden also dessen Projekt
        Quellen nicht einbinden, denn diese sind - geheim.</para>

        <para>Normalerweise werden Projektquellen in Verzeichnissen welche mit
        den Namen der Modulartefakte benannt sind abgelegt. Da Maven aber
        Module erlaubt, welche nicht in Verzeichnissen mit den Namen der
        <varname>artefactId</varname> abgelegt sind, ist es besser Sie
        arbeiten mit dem Ausdruck <varname>\${module.basedir.name}</varname>
        um den tatsächlichen Verzeichnisname zu erhalten
        (<varname>\${module.bsedir.name}</varname> entspricht dem Aufruf
        <code>MavenProject.getBasedir().getName()</code> ). Es ist wichtig,
        sich in Erinnerung zu rufen, dass Module nicht Unterverzeichnisse des
        Projektes sein müssen, welche diese deklariert. Sollte Ihr Projekt
        eine besonders obskure Verzeichnisstruktur aufweisen, so kann es
        passieren, dass Sie auf spezielle <varname>modulSet</varname>
        Deklarationen ausweichen müssen, welche bestimmte Projekte umfassen
        und Ihren Besonderheiten Rechnung tragen.</para>

        <warning>
          <para>Versuchen Sie Ihre eigenen Projektbesonderheiten zu
          minimieren, obwohl Maven sehr flexibel ist, sollten Sie sich zu oft
          beim Konfigurieren wiederfinden so gibt es bestimmt einen
          einfacheren Weg.</para>
        </warning>

        <para>Eine weitere Anmerkung zu <xref
        linkend="ex-include-exclude-moduleSet" />: da wir im allgemeinen die
        Verarbeitung der Untermodule ausgeschlossen haben, ist es wichtig
        sicherzustellen, dass wir diese nun bei der Verarbeitung der direkten
        Untermodule (erste Ebene) nicht auschliessen und die Quellen damit
        verlieren. Mittels der Einstellung
        <varname>excludeSubModuledirectories</varname> welche auf
        <varname>false</varname> gesetzt ist, können wir nun die gleichen
        Datei Ein- und Ausschlussmuster auf die Verzeichnisstrukturen der
        Untermodule welche wir bearbeiten, anwenden. Schliesslich wird in dem
        Beispiel ausgeführt, dass wir an den Ausgaben des Build Prozesses
        dieses <varname>modulSet</varname> nicht interessiert sind. Wir
        schliessen also die Verzeichnisse <filename>/target</filename> aller
        Module aus.</para>

        <para>Wir wollen es nicht unerwähnt lassen, dass der Abschnitt
        <varname>sources</varname> auch fileSet-artige Elemente direkt
        einschliessen kann, zusätzlich zur Unterstützung von verschachtelten
        <varname>fileSets</varname>. Diese Konfigurationselemente werden aus
        Gründen der Rückwärtskompatibilität zu früheren Versionen des Assembly
        Plugin (bis und mit Version 2.1) beibehalten. Diese Vorgängerversionen
        boten keine Unterstützung für mehrfache <varname>fileSet</varname>
        Deklarationen innerhalb eines Modules ohne hierfür eine separate
        <varname>moduleSet</varname> Deklaration bereitzustellen. Diese
        Möglichkeiten sind nun veraltet und sollten nicht weiter benutzt
        werden.</para>
      </section>

      <section id="assemblies-sect-interpolate-modulesets">
        <title>Interpolation des <sgmltag>outputDirectoryMapping</sgmltag> in
        <sgmltag>moduleSets</sgmltag></title>

        <para>Im Beispiel <xref linkend="ex-include-exclude-moduleSet" />
        haben wir das Element <varname>outputDirectoryMapping</varname>
        benutzt, um den Namen der Verzeichnisse in welchen jedes Modul Quellen
        abgelegt werden anzupassen. Die Ausdrücke welche in diesem Element
        enthalten sind, werden in der genau gleichen Weise aufgelöst, wie die
        für <varname>outputFileMapping</varname> - in Bündeln von
        Abhängigkeiten - der Fall ist (Vergleichen Sie hierzu die Beschreibung
        unter <xref linkend="assemblies-sect-output-algorithm" />).</para>

        <para>Im Beispiel <xref linkend="ex-include-exclude-moduleSet" />
        haben wir den Ausdruck <filename>\${module.basedir.name}</filename>
        benutzt. Sie werden bemerkt haben, dass die Wurzel dieses Ausdrucks
        '<varname>module</varname>' nicht in der Beschreibung des Algorythmus
        aufgeführt ist der die Auflösung der Abhängigkeiten beschreibt. Dieses
        Wurzelobjekt ist spezifisch für die Konfiguration von
        <varname>modulSets</varname>. Die Verarbeitung entspricht genau der
        von <filename>\${artifact.*}</filename>-Referenzen welche innerhalb
        des Elements <varname>outputFilemapping</varname> vorkommt, nur dass
        es nun auf des Moduls MavenProjekt, Artifact sowie ArtifactHandler
        Instanzen angewandt wird, statt auf die der Abhängigkeits
        Artefakte.</para>
      </section>

      <section id="assemblies-sect-binaries">
        <title>Binaries section</title>

        <para>Genau wie der Abschitt über Quellen sich vorrangig damit
        befasst, Module in Quellformat einzubinden, so ist der Abschnitt über
        Binärdaten vorranging damit befasst das Erzeugnis eines Moduls
        einzubinden, oder dessen Artefakt. Obwohl dieser Abschnitt primär dazu
        dient <varname>dependencySet</varname>s zu definieren welche auf die
        Module eines Bündels anzuwenden sind, so gibt es darüber hinaus eine
        Anzahl weiterer Funktionen einzigartig zur Anwendung auf
        Modulartefakte welche sich lohnen anzusehen: attachmentClassifier und
        includeDependencies. Darüberhinaus beinhaltet der Abschnitt über
        Binaries Optionen ähnlich derer des Abschnittes
        <varname>dependencySet</varname>, welche sich auf die Verarbeitung des
        Modulartefakts selbst beziehen. Diese sind: <sgmltag>unpack</sgmltag>,
        <sgmltag>outputFileNameMapping</sgmltag>,
        <sgmltag>outputDirectory</sgmltag>, <sgmltag>directoryMode</sgmltag>,
        sowie <sgmltag>fileMode</sgmltag>. Schliesslich können die Modul
        Binaries einen Abschnitt <varname>dependencySet</varname> beinhalten,
        um darzustellen, wie jeden Modul Abhängigkeiten in ein Assembly Archiv
        eingeschlossen werden sollen. Zunächst, lassen Sie uns betrachten, wie
        die oben genannten Optionen dazu benutzt werden können um die
        moduleigenen Artefakte zu verwalten.</para>

        <para>Angenommen wir möchten die JavaDoc Archive aller Module in unser
        Assembly einschliessen. In diesem Fall sind uns die weitern
        Abhängigkeiten egal, wir möchten lediglich die
        <filename>javadoc.jar</filename> Datei. Da diese Datei immer als
        Beigabe zum Hauptprojektartefakten besteht, ist es notwendig
        anzugeben, welcher <varname>classifier</varname> benutzt werden soll
        um den Artefakten zu holen. Zur Vereinfachung werden wir nicht weiter
        darauf eingehen, wie die Modul Archive entpackt werden, da diese
        Konfiguration genau die selbe ist, wie wir sie bereits für die
        Abhängigkeits Sätze zuvor in diesem Kapitel benutzt haben. Das
        resultierende Module Büdel sieht dann ungefair wie in <xref
        linkend="ex-include-javadoc-moduleset" /> dargestellt aus.</para>

        <example id="ex-include-javadoc-moduleset">
          <title>Einschliessen von JavaDoc von Modulen in einem
          Assembly</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;binaries&gt;
        &lt;attachmentClassifier&gt;javadoc&lt;/attachmentClassifier&gt;
        &lt;includeDependencies&gt;false&lt;/includeDependencies&gt;
        &lt;outputDirectory&gt;apidoc-jars&lt;/outputDirectory&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>Im Beispiel <xref linkend="ex-include-javadoc-moduleset" />
        setzen wir die Einstellung <varname>includeSubModules</varname> nicht
        explizit, da diese standardmässig auf <varname>true</varname> steht.
        Wir wollen mit Sicherheit alle Module verarbeiten - Untermodule
        eingeschossen - durch die Definition eines Modul Bündels, da wir
        keinerlei Ein- oder Ausschlusskriterien benutzen, welche auf
        Verzeichnisstrukturen der Untermodule passen könnten. Das Element
        <varname>attachmentClassifier</varname> holt den angebundenen
        Artefakten mit dem <varname>classifier</varname> javadoc für jedes
        verarbeitete Modul. Das Element <varname>includeDependencies</varname>
        zeigt dem Assembly Plugin an, dass wir an den Abhängigkeiten des
        Modules kein Interesse haben, sondern nur am JavaDoc-Anhang
        interessiert sind. Am Schluss bestimmt das Element
        <varname>outputDirectory</varname>, dass alle javadoc Archive in einem
        Verzeichnis mit dem Namen <filename>apidoc-jars</filename> unter dem
        Wurzelverzeichnis abgelegt werden.</para>

        <para>Auch wenn wir in diesem Beispiel nichts überkompliziertes
        vollbringen, so ist es dennoch wichtig ein klares Verständnis
        aufzubauen, dass auch hier die gleichen Änderungen des
        Ausdrucks-Auflösungs-Algorythmus gelten, wie diese bereits für das
        Element <varname>outputDirectoryMapping</varname> des Abschittes
        bezüglich der Quellenverarbeitung beschrieben wurden. In anderen
        Worten, alles was bislang unter <filename>\${artifact.*}</filename>
        innerhalb des Element <varname>outputFileMapping</varname> eines
        <varname>dependencySet</varname> zur Verfügung stand, steht hier auch
        unter <filename>\${module.*}</filename> bereit. Das selbe gilt auch
        für das Element <varname>outputFileMapping</varname>, wird dieses
        direkt innerhalb eines Abschnitts Binaries angewandt.</para>

        <para>Schliesslich, lassen Sie uns ein Beispiel ansehen, welches den
        Modul Artefakten und dessen Laufzeiabhängigkeiten verarbeitet. in
        diesem Fall wollen wir den Satz der Artefakte ein jeden Moduls in
        seperate Verzeichnisstrukturen ablegen, entsprechend des Artefakt
        Namen und Version. Das resultierende Modul ist erstaunlich einfach,
        und sieht entsprechend des Beispiels <xref
        linkend="ex-the-big-include" /> aus:</para>

        <example id="ex-the-big-include">
          <title>Einschliessen von Module Artifakten und Abhängigkeiten in
          einem Assembly</title>

          <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;
          \${module.artifactId}-\${module.version}
        &lt;/outputDirectory&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet/&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
  ...
&lt;/assembly&gt;</programlisting>
        </example>

        <para>In <xref linkend="ex-the-big-include" /> kommt ein leeres
        Element <varname>dependencySet</varname> zum Einsatz, da dieses
        standardmäsig ohne Konfiguration bereits alle Laufzeitabhängigkeiten
        enthalten sollte. Mit der Definition von
        <varname>outputDirectory</varname> auf dem Level des Abschnittes
        Binaries, sollten neben den direkten Artefakten des Moduls auch alle
        Abhängigkeiten im gleichen Verzeichnis zusammengefügt werden. Damit
        müssen wir dies in unserem <varname>dependencySet</varname> erst gar
        nicht angeben.</para>

        <para>Im allgemeinen sind Module Binaries recht einfach. In beiden
        Abschnitten, dem Hauptteil, welcher sich mit der Verarbeitung des
        Modul Artfaktes befasst aber auch dem Abschnitt bezüglich der
        Verarbeitung der Abhängigkeiten - ist die Konfiguration sehr Ähnlich
        derer eines Bündels Abhängigkeiten. Natürlich beinhaltet der Abschnitt
        bezüglich Binaries auch Optionen welche steuern ob Abhängigkeiten
        eingeschlossen werden, oder welcher Hauptartefakt zum Zug
        kommt.</para>

        <para>Wie der Abschnitt bezüglich Quellen beinhaltet auch dieser
        Abschnitt einige Konfigurationselemente welche nur wegen der
        Rückwärtskompatibilität bereitgestellt werden. Diese sollten Sie als
        veraltet ansehen. Derartige Elemente umfassen die Unterabschnitte
        <varname>includes</varname> und <varname>excludes</varname>.</para>
      </section>

      <section id="assemblies-sect-modulesets-parent-pom">
        <title><sgmltag>moduleSets</sgmltag>, Parent <acronym>POM</acronym>s
        und das Element <sgmltag>binaries</sgmltag></title>

        <para>Die Ausführungen bezüglich der Verarbeitung von Modulen wollen
        wir mit einer eindringlichen Warnung abschliessen: Es gibt subtile
        Abhängigkeiten des Designs von Maven bezüglich den Abhängigkeiten von
        einem Über- zu einem Untergeordneten Modul und der Verarbeitung der
        Abschnittes Binaries eines Modul Satzes. Sobald ein
        <acronym>POM</acronym> ein übergeordnetes Modul deklariert, so muss
        dieses Modul in der einen oder anderen Art und Weise aufgelöst werden,
        vor ein soches <acronym>POM</acronym> einen Buildlauf erfolgreich
        durchlaufen kann. Sollte das übergeordnete Modul in einem Maven
        Repository zugänglich sein, so besteht kein Problem. Mit der Version
        2.0.9 kann es jedoch zu grösseren Problemen kommen sollte das
        übergeordnete Modul und dessen <acronym>POM</acronym> Teil des
        gleichen Build sein, insbesondere sollte dieses (übergeordnete)
        <acronym>POM</acronym> versuchen ein Assembly mit den Module Binaries
        zu erstellen.</para>

        <para>Maven Version 2.0.9 ordnet Projekte eines multi-modularen Builds
        entsprechen deren Abhängigkeiten, wobei die entsprechenden
        Abhängigkeiten eines Projektes vorgängig erstellt werden. Das Problem
        besteht darin, dass das übergeordnete Modul als Abhängigkeit angesehen
        wird, deren Verarbeitung vor der Ausführung der untergeordneten Module
        abgeschlossen sein muss. Sollte dann ein Teil des Erstellungsprozesses
        eines übergeordneten Moduls darin bestehen ein Assembly zu erstellen,
        welches auf den Ergebnissen der untergeordneten Module aufbaut, so
        werden diese noch nicht bestehen und damit der Prozess mit einem
        Fehler abbrechen. Dies ist ein komplexes und subtiles Problem, welches
        die Möglichkeiten und den Nutzen des Abschnittes Module Binaries des
        Assembly Deskriptors stark einschränkt. Es ist sogar so, dass dies als
        Bug des Assembly Plugin unter: <ulink
        url="http://jira.codehaus.org/browse/MASSEMBLY-97">http://jira.codehaus.org/browse/MASSEMBLY-97</ulink>
        aufgenommen wurde. Es bleibt zu hoffen, dass eine zukünftige Version
        von Maven es schafft, diese Funktionalität wiederherzustellen,
        insbesondere, da die Anforderung 'Vorrangig Übergeordnetes Modul'
        unter Umständen gar nicht unbedingt notwendig ist.</para>
      </section>
    </section>

    <section id="assemblies-sect-repositories">
      <title>Element Repositories</title>

      <para>Der Abschnitt <varname>repositories</varname> stellt eine etwas
      exotischere Funktionalität des Assembly Deskriptors dar, da nur wenige
      Anwendungen nebst Maven die vollen Vorzüge der Maven Repository Struktur
      zu nutzen verstehen. Aus diesem Grund, und da diese Funktionalitäten
      denen des Abschnittes <varname>dependencySet</varname> sehr ähnlich
      sind, werden wir nicht allzuviel Zeit darauf verwenden den Abschnitt
      <varname>repositories</varname> des Assembly Deskriptor detailliert
      einzuführen. In den meisten Fällen sollte es einem Anwender der
      <varname>dependencySets</varname> verstanden hat nicht schwer fallen
      mittels dem Assembly Plugin Repositorien zu erstellen. Wir werden an
      dieser Stelle den Abschnitt <varname>repositories</varname> nicht
      bewerben, und wir werden uns auch nicht die Mühe machen ein elaboriertes
      Beispiel einzuführen. Wir werden uns darauf beschränken einige Warnungen
      auszusprechen für diejenigen welche diese Funktionalität benutzen
      möchten.</para>

      <para>Nach dieser Einführung möchten wir insbesonder auf zwei Funktionen
      des Abschnitts <varname>repositories</varname> hinweisen, welche
      weiterer Erwähnung gebühren: Die erste ist die Eigenschaft
      <varname>includeMetaData</varname>. Wird diese auf
      <varname>true</varname> gesetzt, so werden MetaDaten wie z.B. die
      tatsächlichen Versionen im Fall von <varname>-SNAPSHOT</varname>
      virtuellen Versionen weitergegeben. Standardmässig steht dieser
      Parameter auf <varname>false</varname>. Derzeit sind die einzigen Meta
      Daten welche eingeschlossen werden, sollte dieser Parameter auf
      <varname>true</varname> gesetzt werden, die Informationen des Maven
      Central Repository.</para>

      <para>Die zweite interessante Funktionalität ist der Parameter
      <varname>groupVersionAlignements</varname>. Wiederum ist dieser
      Abschnitt eine Liste der einzelnen
      <varname>groupVersionAlignement</varname> Konfigurationen. Jeder Eintrag
      besteht aus zwei Pflicheinträgen - <varname>id</varname> und
      <varname>version</varname> - zusammen mit dem optionalen Eintrag
      <varname>excludes</varname> welches eine Liste von
      <varname>artifactId</varname> umfasst welche nicht in diese Umordung
      eingeschlossen werden sollen. Unglücklicherweise beeinflusst diese
      Umordnung anscheinend nicht die <acronym>POM</acronym>s innerhalb der
      entsprechenden Repositorien. Weder die der Artefakte welche Teil der
      Umordnung sind, noch solche, welche eine Abhängigkeit zu einem solchen
      Artefakten definiert haben. Dies macht es schwer eine praktische
      Anwendung einer derartigen Umordung zu sehen.</para>

      <para>Im Allgemeinen ist es am einfachsten auf den Abschnitt
      <varname>repositories</varname> die gleichen Prinzipien anzuwenden,
      welche Sie auf <varname>dependencySets</varname> anwenden würden. Auch
      wenn der Abschnitt <varname>repositories</varname> die beiden genannten
      Zusatzoptionen bietet, so werden diese hauptsächlich zum Zwecke der
      Rückwärtskompatibilität geführt und es ist abzusehen, dass diese in der
      Zukunft veralten werden.</para>
    </section>

    <section id="assemblies-sect-managing-root">
      <title>Verwalten des Wurzelverzeichnisses des Assembly</title>

      <para>Jetzt, da wir den Hauptteil des Assembly Deskriptors vorgestellt
      haben, können wir die kontentbezogene Diskussion mit einem etwas
      einfacheren Thema abschliessen: Stammverzeichnisnamensgebung und
      Siteverzeichnisbehandlung.</para>

      <para>Manche werden es als stylistisches Problem abtun und doch ist es
      oftmals wichtig die Kontrolle über die Namensgebung des
      Wurzelverzeichnis des Assemblies zu behalten, oder auch nur die
      Kontrolle darüber ob es ein einziges solches Verzeichnis überhaupt gibt.
      Glücklicherweise erlauben zwei Konfigurationsoptionen im Kern des
      Assemply Deskriptors die einfache Verwaltung des
      Archivwurzelverzeichnisses: <varname>includeBaseDirectory</varname> und
      <varname>baseDirectory</varname>. In Fällen wie dem eines ausführbaren
      <acronym>JAR</acronym>s, benötigen Sie für gewöhnlich gar kein
      Archivwurzelverzeichnis. Sie übergehen dies indem Sie die Eigenschaft
      <varname>includebaseDirectory</varname> auf <varname>false</varname>
      setzen, diese ist standardmässig auf <varname>true</varname> gesetzt.
      Das Ergebnis ist ein Archiv das beim Entpacken mehr als ein Verzeichnis
      im Zielverzeichnis erstellt. Dies wird bei Verzeichnissen welche zum
      Entpacken erstellt werden nicht gerne gesehen, ist jedoch im Fall von
      Archiven welche zum direkten Konsum gedacht sind, wie z.B. ausführbare
      JARs, erlaubt.</para>

      <para>In anderen Fällen ist es wichtig den Namen des Wurzelverzeichnis
      eines Archivs zu bestimmen, unabhängig von dessen <acronym>POM</acronym>
      Version oder anderen Informationen. Standardmässig ist der Wert des
      Elements <varname>baseDirectory</varname> auf
      <varname>\${project.artifactId}-\${project.version}</varname> gesetzt.
      Es kann jedoch auf jeglichen Wert welcher aus einfachen Strings oder
      Ausdrücken welche im Kontext des aktuellen <acronym>POM</acronym>
      ausgewertet werden können gesetzt werden. So zum Beispiel
      <filename>\${project.groupId}-\${project.artifactId}</filename>. Und das
      könnte gute Neuigkeiten für Ihr Dokumentationsteam verheissen - Sie
      haben doch auch eins, oder?</para>

      <para>Eine weitere zur Verfügung stehende Möglichkeit ist die
      Einstellung <varname>includeSiteDirectory</varname>, dessen Standardwert
      <varname>false</varname> ist. Sollte Ihr Projekt zugleich einen Website
      erstellen, unter Einsatz des Site Lifecycle oder des Goals Site Plugin,
      so kann deren Ausgabe eingebunden werden, indem diese Einstellung auf
      <varname>true</varname> gesetzt wird. Allerdings ist diese Funktion
      etwas eingeschränkt, da es lediglich das
      <varname>outputDirectory</varname> des Abschnitts
      <varname>reporting</varname> des aktuellen <acronym>POM</acronym>
      einschliesst (Standard ist <filename>target/site</filename>) und
      berücksichtigt keinerlei Site Verzeichnisse welche in Unterprojekten
      vorhanden sein könnten. Benutzen Sie es wenn es Ihnen nützt, eine gute
      <varname>fileSet</varname>- oder <varname>moduleSet</varname>
      Spezifikation mit entsprechenden Quellen konfiguriert, wird Ihnen den
      gleichen oder besseren Dienst tun. Dies ist ein weiteres Beispiel der
      Unterstüzung von Funktionalität zur Wahrung der Rückwärtskompatibilität.
      Ihre Ansprüche mögen unterschiedlich sein, sollten Sie jedoch einen Site
      erstellen, welcher sich aus den Ausgaben verschiedener Module
      zusammensetzt, sollten Sie den Einsatz von <varname>fileSets</varname>
      oder <varname>moduleSets</varname> erwägen, anstatt die Einstellung
      <varname>includeDirectory</varname> auf <varname>true</varname> zu
      setzen.</para>
    </section>

    <section id="assemblies-sect-componentDescriptors">
      <title><sgmltag>componentDescriptors</sgmltag> und
      <sgmltag>containerDescriptorHandlers</sgmltag></title>

      <para>Um nun die Vorstellung des Assembly Deskriptors abzuschliessen
      sollten wir noch zwei weitere Abschnitte erwähnen:
      <varname>containerDeskriptorHandlers</varname> und
      <varname>componentDeskriptors</varname>. Der Abschnitt
      <varname>containerDescriptorHandlers</varname> bezieht sich auf
      massgeschneiderte Komponenten welche Sie einsetzen um die
      Funktionalitäten des Assembly Plugins zu erweitern. Um genauer zu sein,
      diese Komponenten erlauben es Ihnen, bestimmte Dateien zu bestimmen und
      zu bearbeiten, welche unter Umständen sich aus einer ganzen Anzahl
      Teilbausteinen der Inhalte des Archivs zusammensetzen. Ein gutes
      Beispiel ist eine Komponente welche aus den
      <filename>web.xml</filename>-Dateien von Teilbausteinen und
      <acronym>WAR</acronym>-Fragmenten des Assemblies eine einzige
      <filename>web.xml</filename>-Datei zusammensetzt, die benötigt wird um
      das resultierende Archiv als <acronym>WAR</acronym> einzusetzen.</para>

      <para>The <sgmltag>componentDescriptors</sgmltag> section allows you to
      reference external assembly-descriptor fragments and include them in the
      current descriptor. Component references can be any of the
      following:</para>

      <para>Die Einstellung <varname>componentDescriptors</varname> ermöglicht
      Ihnen externe Assembly Deskriptor Fragmente zu erstellen und diese in
      den aktuellen Deskriptor einzubinden. Derartige externe Referenzen
      können von folgender Art sein:</para>

      <orderedlist>
        <listitem>
          <para>Relative Dateipfade:
          <filename>src/main/assembly/component.xml</filename></para>
        </listitem>

        <listitem>
          <para>Artifact Referenzes:
          <varname>groupId:artifactId:version[:type[:classifier]]</varname></para>
        </listitem>

        <listitem>
          <para>Klassenpfad Resourcen:
          <filename>/assemblies/component.xml</filename></para>
        </listitem>

        <listitem>
          <para>URLs: <ulink
          url="http://www.sonatype.com/component.xml">http://www.sonatype.com/component.xml</ulink></para>
        </listitem>
      </orderedlist>

      <para>Bei der Auflösung eines Komponenten Deskriptors wird - nicht ganz
      zufällig - vom Assembly Plugin dieselbe Abfolge abgearbeitet. Die erste
      zum Erfolg führende Referenz kommt zum Einsatz.</para>

      <para>Komponenten Deskriptoren können viele der inhaltsorientierten
      Abschnitte des Assembly Deskriptors beinhalten mit der Ausnahme von
      <varname>moduleSets</varname>, welche als derart projektspezifisch
      angesehen werden, dass es diese keinen guten Kandidaten zur
      Wiederverwendung abgeben könnten. Ebenfalls Teil des Komponenten
      Deskriptors ist der oben erwähnte Abschnitt
      <varname>containerDescriptorHandler</varname>. Komponenten Deskriptoren
      können keine Formate, assembly id's oder andere Konfigurationen welche
      in Relation zum Wurzelverzeichnis des Assembly Archivs stehen, da alle
      diese einzigartig in der Beziehung zu einem bestimmten Assembly
      Deskriptor gesehen werden. Auch wenn es Sinn machen würde den Abschnitt
      über Formate wiederzuverwenden, diese Eigenschaft wurde bis Version
      2.2-beta-2 des Assembly Plugin nicht realisiert.</para>
    </section>
  </section>

  <section id="assemblies-sect-best-practices">
    <title>Best Practices</title>

    <para>Das Assembly Plugin bietet genügend Freiheiten um viele Probleme auf
    unterschiedliche Art und Weise zu lösen. Sollten Sie eine einzigartige
    Anforderung in Ihrem Projekt vorfinden, so ist die Warscheinlichkeit hoch,
    dass Sie eine der nachfolgend dokumentierten Strategien zum Einsatz
    bringen können, um beinahe jede mögliche Struktur zu erstellen. Dieser
    Abschnitt nun soll Ihnen die verbreiteten Best Practices aufzeigen,
    welche, so Sie sich daran halten, den Einsatz des Assembly Plugins
    produktiver und weniger schmerzhaft gestalten können.</para>

    <section id="assemblies-sect-standard-reusable">
      <title>Standardisierte, wiederverwendbare Assembly Descriptoren</title>

      <para>Bislang haben wir uns hauptsächlich damit befasst einmalige
      Lösungen zu erarbeiten. Lösungen welche einen bestimmten Typ von
      Assembly erzeugen. Was aber macht man wenn man duzende Projekte hat
      welche alle einen bestimmten Typ von Assembly benötigen? Kurz gesagt,
      wie können wir den Aufwand welchen wir aufgebracht haben ein Assembly
      genau so hinzubekommen wie wir es benötigen, sicherstellen und diesen
      Assembly Deskriptor für andere Projekte wiederverwenden ohne hierbei auf
      copy &amp; paste zurückzugreifen?</para>

      <para>Die einfachste Antwort ist den Assembly Deskriptor in einen
      standardisierten, versionierten Artefakten zu überführen und diesen zu
      veröffentlichen. Mit der Veröffentlichung ist es Ihnen möglich,
      festzulegen, dass der Assembly Deskriptor als Plugin Abhängigkeit
      innerhalb des Assembly Plugin Abschnitt des <acronym>POM</acronym>
      definiert wird. Dies führt dazu, dass Maven die Abhängigkeit auflöst und
      den Artefakt in den Klassenpfad einfügt. Damit können Sie den Assembly
      Deskriptor mittels dem Abschnitt <varname>descriptorRefs</varname> der
      Konfiguration in der Assembly Plugin Deklaration einbinden. Um dies
      auszuführen, hier ein beispielhafter Assembly Deskriptor:</para>

      <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;war-fragment&lt;/id&gt;
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
  &lt;/formats&gt;
 &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt;
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;outputDirectory&gt;WEB-INF/lib&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  &lt;fileSets&gt;
    &lt;fileSet&gt;
      &lt;directory&gt;src/main/webapp&lt;/directory&gt;
      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;**/web.xml&lt;/exclude&gt;
      &lt;/excludes&gt;
    &lt;/fileSet&gt;
  &lt;/fileSets&gt;
&lt;/assembly&gt;</programlisting>

      <para>In Ihr Projekt eingebunden bietet dieser Deskriptor einen
      nützlichen Weg den Projektinhalt in einer Art und Weise zu bündeln, dass
      dieser direkt in eine bestehende Webanwendung entpackt werden kann, um
      diese zu erweitern (um zum Beispiel eine Erweiterung einzufügen).
      Sollten Sie jedoch mehr als eines dieser Anwendungsfragmente erzeugen,
      so ist es gut möglich, dass Sie diesen Assembly Deskriptor vorzugsweise
      wiederverwenden und nicht kopieren wollen. Um diesen Deskriptor als
      eigenständigen Artefakten zu veröffentlichen, packen wir diesen in ein
      eigenes Projekt im Verzeichnis
      <filename>src/main/resources/assemblies</filename>.</para>

      <para>Die Projektstruktur dieses Assembly Deskriptor sieht wie folgt
      aus:</para>

      <programlisting>|-- pom.xml
`-- src
    `-- main
        `-- resources
            `-- assemblies
                `-- web-fragment.xml
</programlisting>

      <para>Beachten Sie den Pfad unserer
      <filename>web-fragment.xml</filename> Datei, des Deskriptors.
      Standardmässig wird Maven Dateien aus der Verzeichnisstruktur
      <filename>src/main/resources</filename> in das endgültige Archiv
      (<acronym>JAR</acronym>) einfügen. Das bedeutet aber auch, dass unser
      Deskriptor ohne weitere Konfiguration eingefügt wird. Beachten Sie auch
      den vorangestellten Pfad <filename>/assemblies</filename>; das Assembly
      Plugin erwartet diesen Zusatz vor allen Deskriptoren welche im
      Klassenpfad enthalten sind. Es ist also wichtig, dass wir unseren
      Deskriptor an der korrekten, relativen Stelle ablegen, damit dieser vom
      Assembly Plugin zur Zeit der Verarbeitung gefunden werden kann.</para>

      <para>Beachten Sie darüber hinaus, dass dieses Projekt getrennt von
      Ihrem WebFragment Projekt besteht. Der Assembly Deskriptor wurde ein
      eigener Artefakt mit eigener Version und vielleicht sogar eigenem
      Lebenszyklus. Sobald sie dieses neue Projekt mit Maven installieren
      werden Sie in der Lage sein es in Ihrem WebFragment Projekt zu
      referenzieren. Um dies zu veranschaulichen, Ihr Build Prozess sollte nun
      ungefair so aussehen:</para>

      <screen>$ <command>mvn install</command>
(...)
[INFO] [install:install]
[INFO] Installing (...)/web-fragment-descriptor/target/\
                  web-fragment-descriptor-1.0-SNAPSHOT.jar 
       to /Users/~/.m2/repository/org/sonatype/mavenbook/assemblies/\
          web-fragment-descriptor/1.0-SNAPSHOT/\
          web-fragment-descriptor-1.0-SNAPSHOT.jar
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 5 seconds
(...)</screen>

      <para>Da es zum Web-Fragment-Deskriptor Projekt keine Quellen gibt, wird
      der erzeugte <acronym>JAR</acronym>-Artefakt lediglich unseren
      web-fragment Assembly Deskriptor beinhalten. Lassen Sie uns also nun den
      Deskriptor Artefakten einbinden:</para>

      <programlisting language="xml">&lt;project&gt;
  (...)
  &lt;artifactId&gt;my-web-fragment&lt;/artifactId&gt;
  (...)
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2-beta-2&lt;/version&gt;
        &lt;dependencies&gt;
          &lt;dependency&gt;
            &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
            &lt;artifactId&gt;web-fragment-descriptor&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
          &lt;/dependency&gt;
        &lt;/dependencies&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;assemble&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;single&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;descriptorRefs&gt;
                &lt;descriptorRef&gt;web-fragment&lt;/descriptorRef&gt;
              &lt;/descriptorRefs&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
      (...)
    &lt;/plugins&gt;
  &lt;/build&gt;
  (...)
&lt;/project&gt;
</programlisting>

      <para>Zwei Dinge stechen bei dieser Assembly Plugin Konfiguration
      heraus:</para>

      <itemizedlist>
        <listitem>
          <para>Wir müssen eine Abhängigkeit auf der Stufe des Plugins
          bezüglich unserem neu hinzugefügten web-fragment Artefact einfügen,
          um auf den Assembly Deskriptor mittels Klassenpfad zugreifen zu
          können.</para>
        </listitem>

        <listitem>
          <para>Da wir statt einer Dateistruktur oder Referenz auf ein lokales
          Reppository eine Referenz auf den Klassenpfad benutzen, ist es
          notwendig den Abschnitt <varname>descriptorRefs</varname> statt
          <varname>descriptor</varname> zu einzusetzen. Beachten Sie auch,
          dass obwohl der Assembly Deskriptor tatsächlich unter
          <filename>assemblies/web-fragment.xml</filename> liegt, wir die
          Lokation innerhalb des Klassenpfades ohne den vorangestellten Zusatz
          <filename>/assemblies</filename> angeben. Dies, da das Assembly
          Plugin davon ausgeht, dass mitgelieferte Assembly Deskriptoren immer
          im Klassenpfad unter diesem Zusatz zu finden sind.</para>
        </listitem>
      </itemizedlist>

      <para>Mit diesen Schritten bleibt es Ihnen frei die
      <acronym>POM</acronym> Konfiguration so oft Sie wollen in Projekten
      wiederzuverwenden, und das mit der Sicherheit, dass alle
      web-fragment-Assemblies genau gleich sind. Sollten Sie am Assembly
      Änderungen vornehmen müssen, zum Beispiel um weitere Resourcen
      einzuschliessen oder die Abhängigkeiten oder Datei Sätze anzupassen -
      Sie können einfach die Version des Assembly Deskriptors anpassen und den
      Deskriptor erneut veröffentlichen. <acronym>POM</acronym>s welche den
      Assembly Deskriptor referenzieren, können diesen Artefakten nach deren
      ermessen einbinden.</para>

      <para>Noch eine abschliessende Bemerkung bezüglich Assembly Deskriptor
      Wiederverwendung: Es macht durchaus Sinn auch die Plugin Konfiguration
      wiederzuverwenden, zusätzlich zur Veröffentlichung des Deskriptors als
      Artefakt. Das ist einfach zu bewerkstelligen: Sie fügen einfach die
      zuvor ausgeführte Konfiguration des Abschnitts pluginManagement in Ihr
      oberstes <acronym>POM</acronym> ein. Anschliessend referenzieren Sie die
      geführte Plugin Konfiguration innerhalb Ihren Moduls wie folgt:</para>

      <programlisting language="xml">(...)
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
      &lt;/plugin&gt;
(...)</programlisting>

      <para>Sollten Sie die ausstehende Plugin Konfiguration - im
      vorhergehenden Beispiel dargestellt - zum Abschnitt
      <varname>pluginManagement</varname> ihres übergeordneten obersten
      <acronym>POM</acronym> zugefügt haben, so wird jedes Projekt welches von
      diesem <acronym>POM</acronym> erbt durch anfügen eines minimalen
      Eintrages wie dem oben ausgeführten, die Vorteile der Konfiguration
      nutzen, und von einem fortschrittlichen Assembly Format während des
      Build Gebrauch machen können.</para>
    </section>

    <section id="assemblies-set-dist-assemblies">
      <title>Verteilung (Aggregierung) von Assemblies</title>

      <para>Wie oben ausgeführt bietet das Assembly Plugin viele
      unterschiedliche Möglichkeiten um verschiedenerlei Archivformate zu
      erstellen. Archive für die Distribution sind gewöhnlich sehr gute
      Beispiele hierfür, da diese oftmals verschiedene Module eines
      multi-modularen Build mit deren Abhängigkeiten und weiteren Dateien und
      Artefakten zusammenfassen. Eine Distribution zielt darauf ab, alle
      verschiedenen Quellen in ein einziges Archiv zusammenzufassen welches
      der Benutzer bequem herunterladen, entpacken und mit Zuversicht
      ausführen kann. Wir haben aber auch die potentiellen Nachteile
      betrachtet die es beim Einsatz von <varname>moduleSets</varname> im
      Assembly Deskriptor geben kann - dem, dass im Fall von hierarchischer
      Beziehungen zwischen benachbarten <acronym>POM</acronym>s ein Build
      verunmöglicht wird, da bestimmte Artefakte in bestimmten Fällen nicht
      zur Verfügung stehen.</para>

      <para>Insbesondere im Fall, dass ein Modul <acronym>POM</acronym> dessen
      übergeordnetes <acronym>POM</acronym> referenziert, wobei dieses eine
      Konfiguration eines Assembly Plugins beinhaltet. Hierbei wird im Falle
      eines multi-modularen Build das übergeordnete <acronym>POM</acronym> vor
      den Modul <acronym>POM</acronym> erstellt. Das übergeordnete Assembly
      erwartet für dessen Module gewisse Artefakte vorzufinden, wobei diese
      Module hierbei darauf warten dass der Build des übergeordneten Projektes
      abschliesst. Somit kann der Build nicht abgeschlossen werden (da dieser
      die Artefakte der Module unmöglich finden kann!). In anderen Worten, die
      untergeordneten Projekte hängen von den übergeordneten, und diese
      wiederum von den untergeordneten Projekten ab.</para>

      <para>Beispielhaft wollen wir diese Situation am unten ausgeführten
      Assembly Deskriptor ausführen. Es ist darauf ausgelegt in einem Projekt
      der obersten Hierarchiestufe einer multi-modularen Hierarchie ausgeführt
      zu werden.</para>

      <programlisting language="xml">&lt;assembly&gt;
  &lt;id&gt;distribution&lt;/id&gt;
  &lt;formats&gt;
    &lt;format&gt;zip&lt;/format&gt;
    &lt;format&gt;tar.gz&lt;/format&gt;
    &lt;format&gt;tar.bz2&lt;/format&gt;
  &lt;/formats&gt;
  
  &lt;moduleSets&gt;
    &lt;moduleSet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-web&lt;/include&gt;
      &lt;/includes&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
        &lt;unpack&gt;true&lt;/unpack&gt;
        &lt;includeDependencies&gt;true&lt;/includeDependencies&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet&gt;
            &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
          &lt;/dependencySet&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
    &lt;moduleSet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-addons&lt;/include&gt;
      &lt;/includes&gt;
      &lt;binaries&gt;
        &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
        &lt;includeDependencies&gt;true&lt;/includeDependencies&gt;
        &lt;dependencySets&gt;
          &lt;dependencySet/&gt;
        &lt;/dependencySets&gt;
      &lt;/binaries&gt;
    &lt;/moduleSet&gt;
  &lt;/moduleSets&gt;
&lt;/assembly&gt;</programlisting>

      <para>Im gegebenen Fall eines übergeordneten Projektes - genannt
      <varname>app-parent</varname> - welches aus drei Modulen besteht
      <varname>app-core</varname>, <varname>app-web</varname> und
      <varname>app-addons</varname>, beachten Sie was passiert beim Versuch
      das Projekt zu erstellen passiert:</para>

      <screen>$ <command>mvn package</command>
[INFO] Reactor build order: 
[INFO]   app-parent &lt;----- PARENT BUILDS FIRST
[INFO]   app-core
[INFO]   app-web
[INFO]   app-addons
[INFO] ---------------------------------------------------------------
[INFO] Building app-parent
[INFO]    task-segment: [package]
[INFO] ---------------------------------------------------------------
[INFO] [site:attach-descriptor]
[INFO] [assembly:single {execution: distro}]
[INFO] Reading assembly descriptor: src/main/assembly/distro.xml
[INFO] ---------------------------------------------------------------
[ERROR] BUILD ERROR
[INFO] ---------------------------------------------------------------
[INFO] Failed to create assembly: Artifact:
org.sonatype.mavenbook.assemblies:app-web:jar:1.0-SNAPSHOT (included by module) 
does not have an artifact with a file. Please ensure the package phase is 
run before the assembly is generated.
...</screen>

      <para>Das in der Hierarchie höchststehende Projekt -
      <varname>app-parent</varname> - wird zuerst erstellt. Dies aufgrund der
      Tatsache, dass alle anderen Projekte dieses <acronym>POM</acronym> als
      deren übergeordnetes Projekt ausweisen, welches dieses an die Spitze der
      Build-Reihenfolge zwingt. Das Modul <varname>app-web</varname>, welches
      das Erste innerhalb des Assembly Deskriptor verarbeitete Modul
      darstellt, wurde noch nicht erstellt. Somit besteht auch noch kein
      assoziierter Artefakt, was dazu führt, das das Assembly nicht
      erfolgreich abgearbeitet werden kann.</para>

      <para>Ein Ausweg aus dieser Situation ist es, den Abschnitt
      <varname>execution</varname> der Assembly Plugin Deklaration zu
      entfernen, diese bindet das Plugin an die Lebenszyklus-Phase package des
      übergeordneten <acronym>POM</acronym>, belässt aber den Abschnitt der
      Konfiguration intakt. Daraufhin wird Maven in zwei Aufrufen ausgeführt:
      zunächst mit dem Goal package, um den den multi-modularen Graphen zu
      builden, und anschiessend in einem separaten Aufruf mit dem Goal
      assembly:assembly in einem direkten Aufruf des Assembly Plugin um die
      erstellten Artefakte des vorhergehenden Aufrufs zu verarbeiten und ein
      Distributionsarchiv zu erstellen. Der Aufruf eines derartigen Build
      könnte wie folgt aussehen:</para>

      <screen>$ <command>mvn package assembly:assembly</command></screen>

      <para>Dieser Ansatz hat mehrere Nachteile. Zunächst einmal wird die
      Erstellung des Distributionsarchivs ein zunehmend manueller Prozess
      welcher die Komplexität steigert und sich negativ auf die allgemeine
      Fehleranfälligkeit auswirkt. Zusätzlich kann dieses Vorgehen dazu
      führen, dass angefügte Artefakte - welche wärend eines Buildlaufes in
      Memory zur Verfügung stehen - nun nicht mehr erreichbar sind und daher
      ein zweiter Lauf auf Referenzen welche sich auf das Dateisystem richten
      notwendig machen.</para>

      <para>Statt Artefakte mittels einem <varname>modulSet</varname> aus dem
      multi-modularen Build zusammenzuführen, lohnt es sich oftmals auch eine
      ganz bodenständige Lösung anzuwenden: der Einsatz eines dedizierten
      Projekt Moduls für die Distribution und dem Einsatz von inter-Projekt
      Abhängigkeiten. Mit diesem Ansatz erstellen Sie ein Projekt, dessen
      einzige Aufgabe darin besteht, eine Distribution Ihres Projektes zu
      erstellen. Dessen <acronym>POM</acronym> enthält Abhängigkeitsreferenzen
      zu allen anderen Modulen der Projekthierarchie und konfiguriert das
      Assembly Plugin. Hierbei wird dieses an die Lebenszyklusphase
      <varname>package</varname> gebunden. Der Assembly Deskriptor selbst
      beruht auf dem Abschnitt <varname>dependencySets</varname> statt wie
      zuvor <varname>moduleSets</varname> um die Artefakte zu bündeln und zu
      definieren was denn schliessendlich Teil des Distributionsarchivs wird.
      Dieser Ansatz umgeht die oben angesprochene Tücke der hierarchischen
      Beziehungen und hat den zusätzlichen Vorteil, dass der Abschnitt der
      Konfiguration innerhalb des Assembly Deskriptors wesentlich einfacher
      ist.</para>

      <para>Um diesen Ansatz umzusetzen erstellen wir eine Projektstruktur die
      der des oben ausgeführten ModulSet-Ansatzes sehr ähnlich ist.
      Einschliesslich des neuen Distributionsprojektes kommen wir so zu einem
      Satz von insgesamt fünf Projekten: <varname>app-parent</varname>,
      <varname>app-core</varname>, <varname>app-web</varname>,
      <varname>app-addons</varname> sowie <varname>app-distribution</varname>.
      Das neue <acronym>POM</acronym> des Projektes
      <varname>app-distribution</varname>, wird ungefair wie dieses
      aussehen:</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;artifactId&gt;app-parent&lt;/artifactId&gt;
    &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;artifactId&gt;app-distribution&lt;/artifactId&gt;
  &lt;name&gt;app-distribution&lt;/name&gt;
  
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;artifactId&gt;app-web&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;war&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;artifactId&gt;app-addons&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- Not necessary since it's brought in via app-web.
    &lt;dependency&gt; [2]
      &lt;artifactId&gt;app-core&lt;/artifactId&gt;
      &lt;groupId&gt;org.sonatype.mavenbook.assemblies&lt;/groupId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    --&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>

      <para>Beachten Sie bitte, dass wir die Abhängigkeiten zu den anderen
      Modulen der Projektstruktur aufnehmen müssen, da wir in diesem
      <acronym>POM</acronym> keinen Abschnitt <varname>modules</varname>
      haben, auf welchen wir uns abstützen könnten. Zu bemerken ist
      darüberhinaus, dass wir keine explizite Abhängigkeit zu
      <varname>app-core</varname> definieren, da dies ja bereits in einer
      Abhängigkeit zu <varname>app-web</varname> steht, müssen wir diese
      Abhängigkeit nicht doppelt verarbeiten (oder deren Vearbeitung ein
      zweites mal verhindern).</para>

      <para>Daraufhin, mit dem, dass wir den <filename>distro.xml</filename>
      Assembly Deskriptor in das Projekt <varname>app-distribution</varname>
      verlagern, müssen wir diesen noch Anpassen um den Abschnitt
      <varname>dependencySets</varname> zu benutzen, wie folgt:</para>

      <programlisting language="xml">&lt;assembly&gt;
  ...
  &lt;dependencySets&gt;
    &lt;dependencySet&gt;
      &lt;includes&gt;
        &lt;include&gt;*-web&lt;/include&gt;
      &lt;/includes&gt;
      &lt;useTransitiveDependencies&gt;false&lt;/useTransitiveDependencies&gt;
      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;
      &lt;unpack&gt;true&lt;/unpack&gt;
    &lt;/dependencySet&gt;
    &lt;dependencySet&gt;
      &lt;excludes&gt;
        &lt;exclude&gt;*-web&lt;/exclude&gt;
      &lt;/excludes&gt;
      &lt;useProjectArtifact&gt;false&lt;/useProjectArtifact&gt;
      &lt;outputDirectory&gt;/WEB-INF/lib&lt;/outputDirectory&gt;
    &lt;/dependencySet&gt;
  &lt;/dependencySets&gt;
  ...
&lt;/assembly&gt;
</programlisting>

      <para>Wenn wir den Build aus dem obersten Projekt dieses Mal anstossen,
      bekommen wir ein besseres Resultat:</para>

      <screen>$ <command>mvn package</command>
(...)
[INFO] ---------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] ---------------------------------------------------------------
[INFO] module-set-distro-parent ...............SUCCESS [3.070s]
[INFO] app-core .............................. SUCCESS [2.970s]
[INFO] app-web ............................... SUCCESS [1.424s]
[INFO] app-addons ............................ SUCCESS [0.543s]
[INFO] app-distribution ...................... SUCCESS [2.603s]
[INFO] ---------------------------------------------------------------
[INFO] ---------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------
[INFO] Total time: 10 seconds
[INFO] Finished at: Thu May 01 18:00:09 EDT 2008
[INFO] Final Memory: 16M/29M
[INFO] ---------------------------------------------------------------</screen>

      <para>Wie Sie leicht sehen können, ist der Ansatz über
      <varname>dependencySets</varname> wesentlich robuster und -zumindest bis
      die Maven eigene Logik zur Projekt-Ordnung mit den Möglichkeiten des
      Assembly Plugin aufgeholt hat - bietet weniger Möglichkeiten Fehler zu
      machen.</para>
    </section>
  </section>

  <section id="assemblies-sect-summary">
    <title>Zusammenfassung</title>

    <para>Wie wir in diesem Kapitel gesehen haben, das Maven Assembly Plugin
    bietet viele Möglichkeiten massgeschneiderte Archivformate zu erstellen.
    Obschon die Detaildefinitionen der Archive sehr komplex werden können,
    dass Sie dies nicht müssen sehen wir zum Beispiel beim Einsatz der
    mitgelieferten/eingebauten standard Assembly Deskriptoren. Auch wenn es
    Ihr Ziel ist, ihres Projekts Abhängigkeiten und ausgewählte Projektdateien
    in einer einzigartigen Archivstruktur zusammenzuführen, so muss die
    Erstellung des zugehörigen Assembly Deskriptors keine beschwerliche
    Aufgabe sein.</para>

    <para>Assemblies sind für eine breite Palette Anwendungen nützlich, werden
    aber gewöhnlich dazu eingesetzt Distributionen verschiedener Arten zu
    erstellen. Während es viele verschiedene Möglichkeiteb gibt das Assembly
    Plugin einzusetzen so ist der Einsatz standardisierter Assembly
    Deskriptoren und die Vermeidung von <varname>modulSets</varname> im Fall
    von Distributionen welche Binärdateien enthalten sind zwei sichere Wege
    Probleme zu vermeiden.</para>
  </section>
</chapter>
